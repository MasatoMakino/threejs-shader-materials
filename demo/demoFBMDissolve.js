(()=>{"use strict";var e,n={693:(e,n,t)=>{const i="\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n//added by threejs-shader-materials\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n#include <surface_normal_varying_chunk>\n#include <__expansion_uniform_chunk>\n\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n    #include <mesh_position_vertex>\n    uvPosition = uv;\n\n    #include <uv_vertex>\n    #include <color_vertex>\n    #include <morphcolor_vertex>\n    #include <batching_vertex>\n    \n    #include <beginnormal_vertex>\n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n    \n    #include <surface_normal_vertex_chunk>\n\n    #include <normal_vertex>\n    \n    #include <begin_vertex>\n    \n    #include <__expansion_vertex_chunk>\n    \n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n    \n    vViewPosition = - mvPosition.xyz;\n\n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n\n}";var a=t(753);class r{static getChunkName(){return""}static getChunk(){return""}static getDefines(){return{}}static registerChunk(){a.vxI&&null==a.vxI[this.getChunkName()]&&(a.vxI[this.getChunkName()]=this.getChunk())}static getUniform(){return{}}}class s extends r{static registerChunk(){o.registerChunk(),l.registerChunk()}static getDefines(){return{USE_EXPANSION:!1}}static getUniform(){return{expansionStrength:{value:0}}}}class o extends r{static getChunkName(){return"__expansion_uniform_chunk"}static getChunk(){return"\n    #ifdef USE_EXPANSION\n      uniform float expansionStrength;\n    #endif\n    "}}class l extends r{static getChunkName(){return"__expansion_vertex_chunk"}static getChunk(){return"\n    #ifdef USE_EXPANSION\n      transformed += normal * expansionStrength;\n    #endif\n    "}}var u,c=t(710);class d extends r{static registerChunk(){super.registerChunk(),p.registerChunk(),m.registerChunk(),h.registerChunk()}static getUniform(){return c.LlO.merge([super.getUniform(),{hasMap:{value:!1},map:{value:null}}])}static getMap(e){return e.uniforms.map.value}static setMap(e,n){e.uniforms.map.value=n,e.uniforms.hasMap.value=null!=n}}class p extends r{static getChunkName(){return"map_uniform_chunk"}static getChunk(){return"\n      uniform bool hasMap;\n      uniform sampler2D map;\n    "}}class m extends r{static getChunkName(){return"map_fragment_chunk"}static getChunk(){return"\n      if( hasMap ){\n        vec4 texelColor = texture2D( map, mapUV );\n        diffuseColor *= texelColor;\n      }\n    "}}class h extends r{static getChunkName(){return"__ShaderMaterial__map_fragment_begin_chunk"}static getChunk(){return"\n      vec2 mapUV = uvPosition;\n    "}}class g extends r{static registerChunk(){f.registerChunk(),_.registerChunk(),v.registerChunk(),C.registerChunk(),k.registerChunk()}static getDefines(){return{USE_MESH_POSITION:!1}}}class f extends r{static getChunkName(){return"mesh_phong_uniform"}static getChunk(){return"\n      uniform vec3 diffuse;\n      uniform vec3 emissive;\n      uniform vec3 specular;\n      uniform float shininess;\n      uniform float opacity;\n      uniform bool hasAlphaMap;\n      uniform sampler2D alphaMap;\n    "}}class _ extends r{static getChunkName(){return"mesh_phong_diffuse_color"}static getChunk(){return"\n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n    "}}class v extends r{static getChunkName(){return"mesh_phong_switching_alpha_map"}static getChunk(){return"\n      if( hasAlphaMap ){\n        diffuseColor.a *= texture2D( alphaMap, mapUV ).g;\n      }\n    "}}class C extends r{static getChunkName(){return"mesh_position_varying"}static getChunk(){return"\n    #ifdef USE_MESH_POSITION\n    varying vec3 meshPosition;\n    #endif\n    "}}class k extends r{static getChunkName(){return"mesh_position_vertex"}static getChunk(){return"\n    #ifdef USE_MESH_POSITION\n    meshPosition = position;\n    #endif\n    "}}class x extends r{static registerChunk(){M.registerChunk(),b.registerChunk()}static getDefines(){return{USE_SURFACE_NORMAL:!1}}static getUniform(){return{}}}class M extends r{static getChunkName(){return"surface_normal_varying_chunk"}static getChunk(){return"\n    #ifdef USE_SURFACE_NORMAL\n      varying vec3 surfaceNormal;\n    #endif\n    "}}class b extends r{static getChunkName(){return"surface_normal_vertex_chunk"}static getChunk(){return"\n    #ifdef USE_SURFACE_NORMAL\n      surfaceNormal = normalize( transformedNormal );\n    #endif\n    "}}class y extends r{static registerChunk(){U.registerChunk(),w.registerChunk()}static getUniform(){return{tiles:{value:2},hashLoop:{value:8},amp:{value:.5}}}static getDefines(){return{NUM_OCTAVES:3}}}class U extends r{static getChunkName(){return"tiling_fbm_function_chunk"}static getChunk(){return"\n        // Based On Dave_Hoskins \n        // https://www.shadertoy.com/view/4dlGW2\n        \n        float hash(in vec2 p, in float hashLoop)\n        {\n            p = mod(p, hashLoop);\n            return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\n        }\n        \n        float noise(in vec2 p, in float hashLoop)\n        {\n            p *= hashLoop;\n            vec2 f = fract(p);\n            vec2 u = f*f*(3.0-2.0*f);\n        \n            p = floor(p);\n            float a = hash(p, hashLoop);\n            float b = hash(p + vec2(1.0, 0.0), hashLoop);\n            float c = hash(p + vec2(0.0, 1.0), hashLoop);\n            float d = hash(p + vec2(1.0, 1.0), hashLoop);\n        \n            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n        }\n        \n        // Based On Dave_Hoskins \n        // https://www.shadertoy.com/view/4dlGW2\n        \n        float fbm(in vec2 p)\n        {\n            float v = 0.0;\n            \n            p = mod(p, hashLoop);\n            float a = amp;\n            float hashLoopVal = hashLoop;\n            \n            for (int i = 0; i < NUM_OCTAVES; i++){\n                v += noise(p, hashLoopVal) * a;\n                a *= .5;\n                hashLoopVal *= 2.0;\n            }\n            return v;\n        }\n    "}}class w extends r{static getChunkName(){return"tiling_fbm_uniform_chunk"}static getChunk(){return"\n      uniform float tiles;  \n      uniform float hashLoop;\n      uniform float amp;\n    "}}!function(e){e[e.vertical=4]="vertical",e[e.horizontal=3]="horizontal",e[e.radial=5]="radial"}(u||(u={}));class S extends c.BKk{constructor(e,n,t){super(t),this._opacity=1,t??={},e??=i,n??="\n#define PHONG\n\n#include <mesh_phong_uniform>\n\n//added by threejs-shader-materials\n#include <mesh_position_varying>\nvarying vec2 uvPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n    #include <clipping_planes_fragment>\n    \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n    // #include <alphamap_fragment>\n    #include <mesh_phong_switching_alpha_map>\n    #include <alphatest_fragment>\n    #include <alphahash_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n\n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n\n    // modulation\n    #include <aomap_fragment>\n\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    \n    #include <envmap_fragment>\n    #include <opaque_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n\n}",this.initChunks(),this.initUniforms(),this.initDefines(),this.vertexShader=e,this.fragmentShader=n,this.initDefaultSetting(t)}static getBasicUniforms(){return c.LlO.merge([a.fCn.common,a.fCn.specularmap,a.fCn.envmap,a.fCn.aomap,a.fCn.lightmap,a.fCn.emissivemap,a.fCn.bumpmap,a.fCn.normalmap,a.fCn.displacementmap,a.fCn.gradientmap,a.fCn.fog,a.fCn.lights,{emissive:{value:new c.Q1f(0)},specular:{value:new c.Q1f(1118481)},shininess:{value:30},hasAlphaMap:{value:!1}},x.getUniform(),s.getUniform(),d.getUniform()])}initChunks(){g.registerChunk(),x.registerChunk(),s.registerChunk(),d.registerChunk()}initUniforms(){this.uniforms=c.LlO.merge([S.getBasicUniforms(),s.getUniform(),{}])}initDefines(){this.defines=Object.assign({},g.getDefines(),x.getDefines(),s.getDefines(),this.defines)}initDefaultSetting(e){this.uniformOpacity=this._opacity,this.lights=!0,null==e?.transparent&&(this.transparent=!0)}get color(){return this.uniforms.diffuse.value}set color(e){this.uniforms.diffuse.value=e}get opacity(){return this.uniformOpacity}get uniformOpacity(){return this._opacity}set opacity(e){this.uniformOpacity=e}set uniformOpacity(e){this._opacity=e,this.uniforms?.opacity&&(this.uniforms.opacity.value=e)}get emissive(){return this.uniforms.emissive.value}set emissive(e){this.uniforms.emissive.value=e}get map(){return d.getMap(this)}set map(e){d.setMap(this,e),this.onSetMap(e)}onSetMap(e){}get alphaMap(){return this.uniforms.alphaMap.value}set alphaMap(e){this.uniforms.alphaMap.value=e,this.uniforms.hasAlphaMap.value=null!=e,this.onSetAlphaMap(e)}onSetAlphaMap(e){}startGlow(){this.alphaTest=0,this.depthWrite=!1,this.blending=c.EZo}}c.BKk,c.BKk,c.BKk;var O=t(603);class L extends S{get tiles(){return this.uniforms.tiles.value}set tiles(e){this.uniforms.tiles.value=e}get hashLoop(){return this.uniforms.hashLoop.value}set hashLoop(e){this.uniforms.hashLoop.value=e}get amp(){return this.uniforms.amp.value}set amp(e){this.uniforms.amp.value=e}get progress(){return this.uniforms.progress.value}set progress(e){this.uniforms.progress.value=e}get edgeWeight(){return this.uniforms.edgeWeight.value}set edgeWeight(e){this.uniforms.edgeWeight.value=e}get edgeColor(){return this.uniforms.edgeColor.value}set edgeColor(e){this.uniforms.edgeColor.value=e}constructor(e){super(i,"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n#include <tiling_fbm_uniform_chunk>\nuniform float progress;\nuniform vec3 edgeColor;\nuniform float edgeWeight;\n#include <tiling_fbm_function_chunk>\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main()\n{\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    \n    #include <map_fragment>\n    #include <color_fragment>\n    \n    vec2 uv = uvPosition * tiles;\n\n    float fbmVal = fbm(uv);\n    float bri = 1.0 - smoothstep( progress-0.01, progress, fbmVal );\n\n    float edge = \n          smoothstep( progress-edgeWeight, progress, fbmVal )\n        - smoothstep( progress, progress+edgeWeight, fbmVal );\n    edge = clamp( edge, 0.0, 1.0 );\n\n    vec3 col = diffuseColor.rgb;\n    col += edgeColor * edge;\n\n    diffuseColor.rgb = col;\n    diffuseColor.a *= bri;\n    \n    #include <mesh_phong_switching_alpha_map>\n\n\t// #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <alphahash_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n\n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n\n    // modulation\n    #include <aomap_fragment>\n    \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    \n    #include <envmap_fragment>\n    #include <opaque_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n\n}",e)}initUniforms(){this.uniforms=c.LlO.merge([S.getBasicUniforms(),y.getUniform(),{progress:{value:0},edgeWeight:{value:.1},edgeColor:{value:new c.Q1f(1,1,1)}}])}initChunks(){super.initChunks(),y.registerChunk()}initDefines(){super.initDefines(),this.defines=Object.assign({},y.getDefines(),this.defines)}}class I{static initColorGUI(e,n,t="color"){const i={},a=n[t];return i[t]=a.getHex(),e.addColor(i,t).onChange((e=>{a.setHex(e)})),i}static initColorNodeGUI(e,n,t="color"){const i={},a=n[t];return i[t]=a.value.getHex(),e.addColor(i,t).onChange((e=>{a.value.setHex(e)})),i}static initBasicMaterialGUI(e,n,t="Material"){const i=e.addFolder(t);return this.initMaterialFolder(i,n),i.open(),i}static initMaterialGUI(e,n,t="Material"){const i=this.initBasicMaterialGUI(e,n,t);this.initColorGUI(i,n,"emissive")}static initMaterialFolder(e,n,t=!1){this.initColorGUI(e,n),e.add(n,"transparent");const i=t?"opacity":"uniformOpacity";e.add(n,i,0,1)}static initSpriteMaterialGUI(e,n,t="Material"){const i=e.addFolder(t);this.initMaterialFolder(i,n),i.open()}static initGridMaterialGUI(e,n){this.initMaterialGUI(e,n);const t={mask:"",alphaMap:""},i=e.addFolder("WavyGridMaterial");return i.add(n,"isReversed"),i.add(n,"division",2,256).step(1),i.add(n,"divisionScaleX",0,4).step(1),i.add(t,"mask",{none:"",earth:"./textures/landmask.png"}).onChange((e=>{n.maskTexture=""===e?null:(new c.Tap).load(e)})),i.add(t,"alphaMap",{none:"",earth:"./textures/landmask.png"}).onChange((e=>{n.alphaMap=""===e?null:(new c.Tap).load(e)})),i.open(),i}static initWavyMaterialGUI(e,n){const t=this.initGridMaterialGUI(e,n).addFolder("WavyAnimation");t.add(n,"isAnimate"),t.add(n,"speed",-2,2),t.add(n,"waveFrequency",0,1),t.add(n,"wavePow",0,4),t.add(n,"direction",{horizontal:u.horizontal,vertical:u.vertical,radial:u.radial}),t.add(n,"raisedBottom",0,1),t.open()}static initAnimationGUI(e,n,t="Animation"){const i=e.addFolder(t);i.add(n,"isAnimate"),i.add(n,"speed",-2,2),i.open()}static initRimGUI(e,n,t="Rim Effect Material"){const i=e.addFolder(t);I.initColorGUI(i,n,"rimColor"),i.add(n,"rimStrength",0,4).step(.01),i.add(n,"rimPow",0,4).step(.01),I.initColorGUI(i,n,"insideColor"),i.add(n,"insideStrength",0,4).step(.01),i.add(n,"insidePow",0,8).step(.01),i.open()}static initExpansionGUI(e,n,t="ExpansionMaterial"){const i=e.addFolder("ExpansionMaterial");i.add(n,"expansionStrength",-12,12).step(.01),i.open()}static initFBMTilingGUI(e,n,t="FBM Tiling"){const i=e.addFolder("FBM Tiling");i.add(n,"tiles",1,8).step(1),i.add(n,"hashLoop",2,16).step(1),i.add(n,"amp",0,2).step(.01),i.open()}static initSkyGUI(e,n,t,i){const a={turbidity:10,rayleigh:.15,mieCoefficient:.005,mieDirectionalG:.8,inclination:.07,azimuth:.25,exposure:.75},r=4e5;function s(){const e=n.material.uniforms;e.turbidity.value=a.turbidity,e.rayleigh.value=a.rayleigh,e.mieCoefficient.value=a.mieCoefficient,e.mieDirectionalG.value=a.mieDirectionalG;const s=Math.PI*(a.inclination-.5),o=2*Math.PI*(a.azimuth-.5);t.position.x=r*Math.cos(o),t.position.y=r*Math.sin(o)*Math.sin(s),t.position.z=r*Math.sin(o)*Math.cos(s),e.sunPosition.value.copy(t.position),i.toneMappingExposure=a.exposure}s();const o=e.addFolder("Sky");o.add(a,"turbidity",1,20,.1).onChange(s),o.add(a,"rayleigh",0,4,.001).onChange(s),o.add(a,"mieCoefficient",0,.1,.001).onChange(s),o.add(a,"mieDirectionalG",0,1,.001).onChange(s),o.add(a,"inclination",0,1,1e-4).onChange(s),o.add(a,"azimuth",0,1,1e-4).onChange(s),o.add(a,"exposure",0,1,1e-4).onChange(s),o.open()}}var G=t(580),N=t(785);class E{static initScene(){return new c.Z58}static initLight(e){const n=new c.$p8(16777215,Math.PI);return e.add(n),n}static initCamera(e,n,t,i=400){const a=new c.ubm(45,n/t,1,i);return a.position.set(0,0,100),a.updateMatrixWorld(!1),e.add(a),a}static initControl(e,n){let t;null!=n&&(t=n.domElement);const i=new G.N(e,t);return i.update(),i}static initRenderer(e,n,t=0,i=!0){const r=new a.JeP({antialias:i});return r.setClearColor(new c.Q1f(t)),r.setSize(e,n),r.setPixelRatio(window.devicePixelRatio),r.domElement.style.backgroundColor="#"+t.toString(16).padStart(6,"0"),document.body.appendChild(r.domElement),console.log("three.js revision: ",c.sPf),r}static initHelper(e){const n=new c.IzY(30);e.add(n)}static initSky(e,n,t){t.toneMapping=c.FV;const i=new c.eaF(new c.Gu$(2e4,16,8),new c.V9B({color:16777215}));i.position.y=-7e5,i.visible=!1,e.add(i);const a=new N.m;a.scale.setScalar(45e3),e.add(a),I.initSkyGUI(n,a,i,t)}}var P=t(638);class D{constructor(){const e=E.initScene();e.fog=new c.jUj(0,80,160),E.initLight(e);const n=E.initCamera(e,640,480),t=E.initRenderer(640,480);E.initControl(n,t),E.initHelper(e);const i=this.initObject(e);O.w.on("tick",(i=>{t.render(e,n)})),this.initGUI(i)}initObject(e){const n=new c.HiM(16777215,3e3);n.position.set(10,20,30),e.add(n);const t=new c.F1l(n);e.add(t);const i=new c.Gu$(30,32,32),a=new L({fog:void 0!==e.fog});a.color=new c.Q1f(3359846),a.edgeColor=new c.Q1f(8978295),a.progress=.5,a.tiles=2,a.edgeWeight=.2;const r=new c.eaF(i,a);return e.add(r),a}initGUI(e){const n=new P.Ay;I.initMaterialGUI(n,e),this.initGUIMaterial(n,e)}initGUIMaterial(e,n){const t=e.addFolder("FBM Dissolve");t.add(n,"progress",0,1).step(.01),t.add(n,"tiles",1,8).step(1),t.add(n,"edgeWeight",0,1).step(.01),I.initColorGUI(t,n,"edgeColor"),t.add(n,"hashLoop",1,16).step(1),t.add(n,"amp",0,2).step(.01),t.open()}}window.onload=()=>{new D}}},t={};function i(e){var a=t[e];if(void 0!==a)return a.exports;var r=t[e]={exports:{}};return n[e](r,r.exports,i),r.exports}i.m=n,e=[],i.O=(n,t,a,r)=>{if(!t){var s=1/0;for(c=0;c<e.length;c++){for(var[t,a,r]=e[c],o=!0,l=0;l<t.length;l++)(!1&r||s>=r)&&Object.keys(i.O).every((e=>i.O[e](t[l])))?t.splice(l--,1):(o=!1,r<s&&(s=r));if(o){e.splice(c--,1);var u=a();void 0!==u&&(n=u)}}return n}r=r||0;for(var c=e.length;c>0&&e[c-1][2]>r;c--)e[c]=e[c-1];e[c]=[t,a,r]},i.d=(e,n)=>{for(var t in n)i.o(n,t)&&!i.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},i.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),i.j=330,(()=>{var e={330:0};i.O.j=n=>0===e[n];var n=(n,t)=>{var a,r,[s,o,l]=t,u=0;if(s.some((n=>0!==e[n]))){for(a in o)i.o(o,a)&&(i.m[a]=o[a]);if(l)var c=l(i)}for(n&&n(t);u<s.length;u++)r=s[u],i.o(e,r)&&e[r]&&e[r][0](),e[r]=0;return i.O(c)},t=self.webpackChunk_masatomakino_threejs_shader_materials=self.webpackChunk_masatomakino_threejs_shader_materials||[];t.forEach(n.bind(null,0)),t.push=n.bind(null,t.push.bind(t))})();var a=i.O(void 0,[121],(()=>i(693)));a=i.O(a)})();