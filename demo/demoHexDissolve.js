(()=>{"use strict";var e,n={136:(e,n,i)=>{var t,r=i(75);class a{static getChunkName(){return""}static getChunk(){return""}static getDefines(){return{}}static registerChunk(){r.WdD&&null==r.WdD[this.getChunkName()]&&(r.WdD[this.getChunkName()]=this.getChunk())}static getUniform(){return{}}}class s extends a{static registerChunk(){u.registerChunk(),l.registerChunk()}static getDefines(){return{USE_EXPANSION:!1}}static getUniform(){return{expansionStrength:{value:0}}}}class u extends a{static getChunkName(){return"__expansion_uniform_chunk"}static getChunk(){return"\n    #ifdef USE_EXPANSION\n      uniform float expansionStrength;\n    #endif\n    "}}class l extends a{static getChunkName(){return"__expansion_vertex_chunk"}static getChunk(){return"\n    #ifdef USE_EXPANSION\n      transformed += normal * expansionStrength;\n    #endif\n    "}}class o extends a{static registerChunk(){super.registerChunk(),c.registerChunk()}}class c extends a{static getChunkName(){return"hex_grid_function_chunk"}static getChunk(){return"\n    /**\n     * ヘックスの縁までの距離を取得する。\n     */\n    float hexDist(vec2 p)\n    {\n        p = abs(p);\n        float d = dot(p, normalize(vec2(1.0, 1.73)));\n        return max(d, p.x);\n    }\n    \n    /**\n     * uv座標からヘックス固有のxy座標とIDを取得する\n     *\n     * x : ヘックスの中心点からの回転角\n     * y : ヘックスの縁までの距離\n     * zw : ヘックスのID\n     */\n    vec4 hexCoords(vec2 uv)\n    {\n        vec2 r = vec2(1.0, 1.73);\n        vec2 h = r * 0.5;\n        vec2 a = mod(uv, r) - h;\n        vec2 b = mod(uv - h, r) - h;\n    \n        vec2 gv = length(a) < length(b) ? a : b;\n        vec2 id = uv - gv;\n    \n        float x = atan(gv.x, gv.y);\n        float y = 0.5 - hexDist(gv);\n    \n        return vec4(x, y, id);\n    }\n    "}}class d extends a{static registerChunk(){super.registerChunk(),m.registerChunk(),g.registerChunk(),p.registerChunk()}static getUniform(){return r.rDY.merge([super.getUniform(),{hasMap:{value:!1},map:{value:null}}])}static getMap(e){return e.uniforms.map.value}static setMap(e,n){e.uniforms.map.value=n,e.uniforms.hasMap.value=null!=n}}class m extends a{static getChunkName(){return"map_uniform_chunk"}static getChunk(){return"\n      uniform bool hasMap;\n      uniform sampler2D map;\n    "}}class g extends a{static getChunkName(){return"map_fragment_chunk"}static getChunk(){return"\n      if( hasMap ){\n        vec4 texelColor = texture2D( map, mapUV );\n        diffuseColor *= texelColor;\n      }\n    "}}class p extends a{static getChunkName(){return"__ShaderMaterial__map_fragment_begin_chunk"}static getChunk(){return"\n      vec2 mapUV = uvPosition;\n    "}}class h extends a{static registerChunk(){f.registerChunk(),_.registerChunk()}static getUniform(){return{division:{value:32},divisionScaleX:{value:1}}}}class f extends a{static getChunkName(){return"repeat_pattern_uniform_chunk"}static getChunk(){return"\n      uniform float division;\n      uniform float divisionScaleX;\n    "}}class _ extends a{static getChunkName(){return"repeat_pattern_fragment_chunk"}static getChunk(){return"\n      vec2 uv =\n        uvPosition\n        * vec2( division * divisionScaleX, division);\n    "}}class v extends h{static registerChunk(){super.registerChunk(),k.registerChunk(),x.registerChunk()}static getUniform(){return r.rDY.merge([super.getUniform(),{hasMaskTexture:{value:!1},maskTexture:{value:null}}])}static getMaskTexture(e){return e.uniforms.maskTexture.value}static setMaskTexture(e,n){e.uniforms.maskTexture.value=n,e.uniforms.hasMaskTexture.value=null!=n}}class k extends a{static getChunkName(){return"mask_map_uniform_chunk"}static getChunk(){return"\n      uniform bool hasMaskTexture;\n      uniform sampler2D maskTexture;\n    "}}class x extends a{static getChunkName(){return"mask_map_fragment_chunk"}static getChunk(){return"\n      float mask = 1.0;\n      if( hasMaskTexture ){\n        vec2 uVm = id / vec2( division * divisionScaleX, division);\n        mask = texture2D( maskTexture, uVm ).g;\n      }\n    "}}class C extends a{static registerChunk(){M.registerChunk(),y.registerChunk(),U.registerChunk(),S.registerChunk(),b.registerChunk()}static getDefines(){return{USE_MESH_POSITION:!1}}}class M extends a{static getChunkName(){return"mesh_phong_uniform"}static getChunk(){return"\n      uniform vec3 diffuse;\n      uniform vec3 emissive;\n      uniform vec3 specular;\n      uniform float shininess;\n      uniform float opacity;\n      uniform bool hasAlphaMap;\n      uniform sampler2D alphaMap;\n    "}}class y extends a{static getChunkName(){return"mesh_phong_diffuse_color"}static getChunk(){return"\n      vec4 diffuseColor = vec4( diffuse, opacity );\n      ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n      vec3 totalEmissiveRadiance = emissive;\n    "}}class U extends a{static getChunkName(){return"mesh_phong_switching_alpha_map"}static getChunk(){return"\n      if( hasAlphaMap ){\n        diffuseColor.a *= texture2D( alphaMap, mapUV ).g;\n      }\n    "}}class S extends a{static getChunkName(){return"mesh_position_varying"}static getChunk(){return"\n    #ifdef USE_MESH_POSITION\n    varying vec3 meshPosition;\n    #endif\n    "}}class b extends a{static getChunkName(){return"mesh_position_vertex"}static getChunk(){return"\n    #ifdef USE_MESH_POSITION\n    meshPosition = position;\n    #endif\n    "}}class w extends a{static registerChunk(){E.registerChunk()}static getUniform(){return{isReversed:{value:!1}}}}class E extends a{static getChunkName(){return"reversible_uniform_chunk"}static getChunk(){return"\n      uniform bool isReversed;\n    "}}class I extends a{static registerChunk(){D.registerChunk(),N.registerChunk()}static getDefines(){return{USE_SURFACE_NORMAL:!1}}static getUniform(){return{}}}class D extends a{static getChunkName(){return"surface_normal_varying_chunk"}static getChunk(){return"\n    #ifdef USE_SURFACE_NORMAL\n      varying vec3 surfaceNormal;\n    #endif\n    "}}class N extends a{static getChunkName(){return"surface_normal_vertex_chunk"}static getChunk(){return"\n    #ifdef USE_SURFACE_NORMAL\n      surfaceNormal = normalize( transformedNormal );\n    #endif\n    "}}!function(e){e[e.vertical=4]="vertical",e[e.horizontal=3]="horizontal",e[e.radial=5]="radial"}(t||(t={}));class P extends r.jyz{constructor(e,n,i){super(i),this._opacity=1,null!=i||(i={}),null!=e||(e="\n#define PHONG\n\nvarying vec3 vViewPosition;\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n#include <surface_normal_varying_chunk>\n#include <__expansion_uniform_chunk>\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n    #include <mesh_position_vertex>\n    uvPosition = uv;\n\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n    \n    #include <beginnormal_vertex>\n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <surface_normal_vertex_chunk>\n    #include <normal_vertex>\n    \n    #include <begin_vertex>\n    \n    #include <__expansion_vertex_chunk>\n    \n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n    \n    vViewPosition = - mvPosition.xyz;\n\n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n}\n"),null!=n||(n="\n#define PHONG\n\n#include <mesh_phong_uniform>\n#include <mesh_position_varying>\nvarying vec2 uvPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n    #include <clipping_planes_fragment>\n    \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n    // #include <alphamap_fragment>\n    #include <mesh_phong_switching_alpha_map>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    #include <output_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"),this.initChunks(),this.initUniforms(),this.initDefines(),this.vertexShader=e,this.fragmentShader=n,this.initDefaultSetting(i)}static getBasicUniforms(){return r.rDY.merge([r.rBU.common,r.rBU.specularmap,r.rBU.envmap,r.rBU.aomap,r.rBU.lightmap,r.rBU.emissivemap,r.rBU.bumpmap,r.rBU.normalmap,r.rBU.displacementmap,r.rBU.gradientmap,r.rBU.fog,r.rBU.lights,{emissive:{value:new r.Ilk(0)},specular:{value:new r.Ilk(1118481)},shininess:{value:30},hasAlphaMap:{value:!1}},I.getUniform(),s.getUniform(),d.getUniform()])}initChunks(){C.registerChunk(),I.registerChunk(),s.registerChunk(),d.registerChunk()}initUniforms(){this.uniforms=r.rDY.merge([P.getBasicUniforms(),s.getUniform(),{}])}initDefines(){this.defines=Object.assign({},C.getDefines(),I.getDefines(),s.getDefines(),this.defines)}initDefaultSetting(e){this.uniformOpacity=this._opacity,this.lights=!0}get color(){return this.uniforms.diffuse.value}set color(e){this.uniforms.diffuse.value=e}get opacity(){return this.uniformOpacity}get uniformOpacity(){return this._opacity}set opacity(e){this.uniformOpacity=e}set uniformOpacity(e){var n;this._opacity=e,(null===(n=this.uniforms)||void 0===n?void 0:n.opacity)&&(this.uniforms.opacity.value=e)}get emissive(){return this.uniforms.emissive.value}set emissive(e){this.uniforms.emissive.value=e}get map(){return d.getMap(this)}set map(e){d.setMap(this,e),this.onSetMap(e)}onSetMap(e){}get alphaMap(){return this.uniforms.alphaMap.value}set alphaMap(e){this.uniforms.alphaMap.value=e,this.uniforms.hasAlphaMap.value=null!=e,this.onSetAlphaMap(e)}onSetAlphaMap(e){}startGlow(){this.alphaTest=0,this.depthWrite=!1,this.blending=r.WMw}}class G extends P{get division(){return this.uniforms.division.value}set division(e){this.uniforms.division.value=e}get divisionScaleX(){return this.uniforms.divisionScaleX.value}set divisionScaleX(e){this.uniforms.divisionScaleX.value=e}get isReversed(){return this.uniforms.isReversed.value}set isReversed(e){this.uniforms.isReversed.value=e}get maskTexture(){return v.getMaskTexture(this)}set maskTexture(e){v.setMaskTexture(this,e)}initChunks(){super.initChunks(),v.registerChunk(),w.registerChunk()}static getBasicUniforms(){return r.rDY.merge([P.getBasicUniforms(),w.getUniform(),v.getUniform()])}initDefaultSetting(e){super.initDefaultSetting(e),null==e.transparent&&(this.transparent=!0)}}var O=i(163);class R extends G{get progress(){return this.uniforms.progress.value}set progress(e){this.uniforms.progress.value=e}get delay(){return this.uniforms.delay.value}set delay(e){this.uniforms.delay.value=e}get isAscending(){return this.uniforms.isAscending.value}set isAscending(e){this.uniforms.isAscending.value=e}get gridWeight(){return this.uniforms.gridWeight.value}set gridWeight(e){this.uniforms.gridWeight.value=e}get gridEmissive(){return this.uniforms.gridEmissive.value}set gridEmissive(e){this.uniforms.gridEmissive.value=e}get gridEmissiveWeight(){return this.uniforms.gridEmissiveWeight.value}set gridEmissiveWeight(e){this.uniforms.gridEmissiveWeight.value=e}constructor(e){super(null,"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n//user settings\n#include <repeat_pattern_uniform_chunk>\n#include <mask_map_uniform_chunk>\n#include <reversible_uniform_chunk>\nuniform float progress;\nuniform float delay;\nuniform float gridWeight;\nuniform bool isAscending;\n\nuniform vec3 gridEmissive;\nuniform float gridEmissiveWeight;\n#include <hex_grid_function_chunk>\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nfloat reverse( float val, bool isReversed){\n  return isReversed ? 1.0 - val : val;\n}\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n\n    #include <repeat_pattern_fragment_chunk>    \n    vec4 hc = hexCoords( uv );\n    vec2 id = hc.zw;\n\n    #include <mask_map_fragment_chunk>\n  \n    float range = 1.0 - delay;\n    float rateY = isAscending \n      ? ( division-id.y ) / division\n      : id.y  / division;\n  \n    float currentProgress = progress - (rateY * delay);\n    currentProgress /= range;\n    currentProgress = clamp( currentProgress, 0.0, 1.0);\n  \n    float w = gridWeight + currentProgress / 2.0 + (1.0 - mask);\n    w = clamp( w, 0.0, 1.0);\n    float margin = clamp ( w * 0.33, 0.00, 0.02 );\n  \n    float gridLine = smoothstep(w, w + margin, hc.y);\n    gridLine =  reverse ( gridLine , isReversed);\n    diffuseColor.a *= gridLine ;\n    \n    float emmesiveWeight = currentProgress / 2.0 * gridEmissiveWeight;\n    emmesiveWeight =  reverse ( emmesiveWeight, isReversed );\n    float emissiveVal = smoothstep(emmesiveWeight, emmesiveWeight + margin, hc.y);\n    emissiveVal = 1.0 - emissiveVal;\n    diffuseColor.rgb += gridEmissive * emissiveVal;\n\n    #include <mesh_phong_switching_alpha_map>\n\n    // #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    #include <output_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}",e)}initUniforms(){this.uniforms=r.rDY.merge([G.getBasicUniforms(),{progress:{value:0},delay:{value:.8},gridWeight:{value:0},isAscending:{value:!0},gridEmissive:{value:new r.Ilk(0)},gridEmissiveWeight:{value:2.5}}])}initChunks(){super.initChunks(),o.registerChunk()}}class W{static initColorGUI(e,n,i="color"){const t={},r=n[i];return t[i]=r.getHex(),e.addColor(t,i).onChange((e=>{r.setHex(e)})),t}static initBasicMaterialGUI(e,n,i="Material"){const t=e.addFolder(i);return this.initMaterialFolder(t,n),t.open(),t}static initMaterialGUI(e,n,i="Material"){const t=this.initBasicMaterialGUI(e,n,i);this.initColorGUI(t,n,"emissive")}static initMaterialFolder(e,n){this.initColorGUI(e,n),e.add(n,"transparent"),e.add(n,"uniformOpacity",0,1)}static initSpriteMaterialGUI(e,n,i="Material"){const t=e.addFolder(i);this.initMaterialFolder(t,n),t.open()}static initGridMaterialGUI(e,n){this.initMaterialGUI(e,n);const i={mask:"",alphaMap:""},t=e.addFolder("WavyGridMaterial");return t.add(n,"isReversed"),t.add(n,"division",2,256).step(1),t.add(n,"divisionScaleX",0,4).step(1),t.add(i,"mask",{none:"",earth:"./textures/landmask.png"}).onChange((e=>{n.maskTexture=""===e?null:(new r.dpR).load(e)})),t.add(i,"alphaMap",{none:"",earth:"./textures/landmask.png"}).onChange((e=>{n.alphaMap=""===e?null:(new r.dpR).load(e)})),t.open(),t}static initWavyMaterialGUI(e,n){const i=this.initGridMaterialGUI(e,n).addFolder("WavyAnimation");i.add(n,"isAnimate"),i.add(n,"speed",-2,2),i.add(n,"waveFrequency",0,1),i.add(n,"wavePow",0,4),i.add(n,"direction",{horizontal:t.horizontal,vertical:t.vertical,radial:t.radial}),i.add(n,"raisedBottom",0,1),i.open()}static initAnimationGUI(e,n,i="Animation"){const t=e.addFolder(i);t.add(n,"isAnimate"),t.add(n,"speed",-2,2),t.open()}static initRimGUI(e,n,i="Rim Effect Material"){const t=e.addFolder(i);W.initColorGUI(t,n,"rimColor"),t.add(n,"rimStrength",0,4).step(.01),t.add(n,"rimPow",0,4).step(.01),W.initColorGUI(t,n,"insideColor"),t.add(n,"insideStrength",0,4).step(.01),t.add(n,"insidePow",0,8).step(.01),t.open()}static initExpansionGUI(e,n,i="ExpansionMaterial"){const t=e.addFolder("ExpansionMaterial");t.add(n,"expansionStrength",-12,12).step(.01),t.open()}static initFBMTilingGUI(e,n,i="FBM Tiling"){const t=e.addFolder("FBM Tiling");t.add(n,"tiles",1,8).step(1),t.add(n,"hashLoop",2,16).step(1),t.add(n,"amp",0,2).step(.01),t.open()}static initSkyGUI(e,n,i,t){const r={turbidity:10,rayleigh:.15,mieCoefficient:.005,mieDirectionalG:.8,inclination:.07,azimuth:.25,exposure:.75},a=4e5;function s(){const e=n.material.uniforms;e.turbidity.value=r.turbidity,e.rayleigh.value=r.rayleigh,e.mieCoefficient.value=r.mieCoefficient,e.mieDirectionalG.value=r.mieDirectionalG;const s=Math.PI*(r.inclination-.5),u=2*Math.PI*(r.azimuth-.5);i.position.x=a*Math.cos(u),i.position.y=a*Math.sin(u)*Math.sin(s),i.position.z=a*Math.sin(u)*Math.cos(s),e.sunPosition.value.copy(i.position),t.toneMappingExposure=r.exposure}s();const u=e.addFolder("Sky");u.add(r,"turbidity",1,20,.1).onChange(s),u.add(r,"rayleigh",0,4,.001).onChange(s),u.add(r,"mieCoefficient",0,.1,.001).onChange(s),u.add(r,"mieDirectionalG",0,1,.001).onChange(s),u.add(r,"inclination",0,1,1e-4).onChange(s),u.add(r,"azimuth",0,1,1e-4).onChange(s),u.add(r,"exposure",0,1,1e-4).onChange(s),u.open()}}var A=i(12),L=i(659);class B{static initScene(){return new r.xsS}static initLight(e){const n=new r.Mig(16777215,1);return e.add(n),n}static initCamera(e,n,i,t=400){const a=new r.cPb(45,n/i,1,t);return a.position.set(0,0,100),a.updateMatrixWorld(!1),e.add(a),a}static initControl(e,n){let i;null!=n&&(i=n.domElement);const t=new A.z(e,i);return t.update(),t}static initRenderer(e,n,i=0,t=!0){const a=new r.CP7({antialias:t});return a.setClearColor(new r.Ilk(i)),a.setSize(e,n),a.setPixelRatio(window.devicePixelRatio),document.body.appendChild(a.domElement),a}static initHelper(e){const n=new r.y8_(30);e.add(n)}static initSky(e,n,i){i.toneMapping=r.LY2;const t=new r.Kj0(new r.Aip(2e4,16,8),new r.vBJ({color:16777215}));t.position.y=-7e5,t.visible=!1,e.add(t);const a=new L.q;a.scale.setScalar(45e3),e.add(a),W.initSkyGUI(n,a,t,i)}}var T=i(899);class F{constructor(){const e=B.initScene();e.fog=new r.ybr(0,80,160),B.initLight(e);const n=B.initCamera(e,640,480),i=B.initRenderer(640,480);B.initControl(n,i),B.initHelper(e);const t=this.initObject(e);O.Fz.addEventListener(O.M9.tick,(t=>{i.render(e,n)})),this.initGUI(t)}initObject(e){const n=new r.cek(16777215,1,0,2);n.position.set(10,20,30),e.add(n);const i=new r.xG9(n);e.add(i);const t=new r.xo$(10,64,64),a=new R({fog:void 0!==e.fog});a.color=new r.Ilk(4473924),a.delay=.8,a.gridEmissive=new r.Ilk(10092441);const s=new r.Kj0(t,a);return e.add(s),a}initGUI(e){const n=new T.ZP;W.initGridMaterialGUI(n,e),this.initGUIMaterial(n,e)}initGUIMaterial(e,n){const i=e.addFolder("HexDissolveMaterial");i.add(n,"progress",0,1).step(.01),i.add(n,"delay",0,1).step(.01),i.add(n,"gridWeight",0,.5).step(.01),i.add(n,"isAscending"),W.initColorGUI(i,n,"gridEmissive"),i.add(n,"gridEmissiveWeight",0,3).step(.01),i.open()}}window.onload=()=>{new F}}},i={};function t(e){var r=i[e];if(void 0!==r)return r.exports;var a=i[e]={exports:{}};return n[e](a,a.exports,t),a.exports}t.m=n,e=[],t.O=(n,i,r,a)=>{if(!i){var s=1/0;for(c=0;c<e.length;c++){for(var[i,r,a]=e[c],u=!0,l=0;l<i.length;l++)(!1&a||s>=a)&&Object.keys(t.O).every((e=>t.O[e](i[l])))?i.splice(l--,1):(u=!1,a<s&&(s=a));if(u){e.splice(c--,1);var o=r();void 0!==o&&(n=o)}}return n}a=a||0;for(var c=e.length;c>0&&e[c-1][2]>a;c--)e[c]=e[c-1];e[c]=[i,r,a]},t.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return t.d(n,{a:n}),n},t.d=(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),t.j=727,(()=>{var e={727:0};t.O.j=n=>0===e[n];var n=(n,i)=>{var r,a,[s,u,l]=i,o=0;if(s.some((n=>0!==e[n]))){for(r in u)t.o(u,r)&&(t.m[r]=u[r]);if(l)var c=l(t)}for(n&&n(i);o<s.length;o++)a=s[o],t.o(e,a)&&e[a]&&e[a][0](),e[a]=0;return t.O(c)},i=self.webpackChunkthreejs_shader_materials=self.webpackChunkthreejs_shader_materials||[];i.forEach(n.bind(null,0)),i.push=n.bind(null,i.push.bind(i))})();var r=t.O(void 0,[736],(()=>t(136)));r=t.O(r)})();