(()=>{"use strict";var e,n={672:(e,n,i)=>{var t,r=i(75);class a{static getChunkName(){return""}static getChunk(){return""}static getDefines(){return{}}static registerChunk(){r.WdD&&null==r.WdD[this.getChunkName()]&&(r.WdD[this.getChunkName()]=this.getChunk())}static getUniform(){return{}}}class o extends a{static registerChunk(){l.registerChunk(),s.registerChunk()}static getDefines(){return{USE_SURFACE_NORMAL:!1}}static getUniform(){return{}}}class l extends a{static getChunkName(){return"surface_normal_varying_chunk"}static getChunk(){return"\n    #ifdef USE_SURFACE_NORMAL\n      varying vec3 surfaceNormal;\n    #endif\n    "}}class s extends a{static getChunkName(){return"surface_normal_vertex_chunk"}static getChunk(){return"\n    #ifdef USE_SURFACE_NORMAL\n      surfaceNormal = normalize( transformedNormal );\n    #endif\n    "}}!function(e){e[e.vertical=4]="vertical",e[e.horizontal=3]="horizontal",e[e.radial=5]="radial"}(t||(t={}));class d extends r.jyz{constructor(e,n,i){super(i),this._opacity=1,this.uniforms=d.getBasicUniforms(),this.vertexShader=null!=e?e:"\n\n#include <surface_normal_varying_chunk>\nvarying vec3 vViewPosition;\nvarying vec2 uvPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n    uvPosition = uv;\n\t\n    #include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n    //For Rim Effect\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <surface_normal_vertex_chunk>\n    vViewPosition = - mvPosition.xyz;\n  \n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",this.fragmentShader=null!=n?n:"\nuniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t// modulation\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",o.registerChunk(),this.initDefines(),this.uniformOpacity=this._opacity}static getBasicUniforms(){return r.rDY.merge([r.rBU.common,r.rBU.specularmap,r.rBU.envmap,r.rBU.aomap,r.rBU.lightmap,r.rBU.fog])}get color(){return this.uniforms.diffuse.value}set color(e){this.uniforms.diffuse.value=e}get uniformOpacity(){return this._opacity}set uniformOpacity(e){var n;this._opacity=e,(null===(n=this.uniforms)||void 0===n?void 0:n.opacity)&&(this.uniforms.opacity.value=e)}initDefines(){this.defines=Object.assign({},o.getDefines(),this.defines)}}var c=i(163);class u extends d{get rimPow(){return this.uniforms.rimPow.value}set rimPow(e){this.uniforms.rimPow.value=e}get rimStrength(){return this.uniforms.rimStrength.value}set rimStrength(e){this.uniforms.rimStrength.value=e}get rimColor(){return this.uniforms.rimColor.value}set rimColor(e){this.uniforms.rimColor.value=e}get insidePow(){return this.uniforms.insidePow.value}set insidePow(e){this.uniforms.insidePow.value=e}get insideStrength(){return this.uniforms.insideStrength.value}set insideStrength(e){this.uniforms.insideStrength.value=e}get insideColor(){return this.uniforms.insideColor.value}set insideColor(e){this.uniforms.insideColor.value=e}constructor(e){super(null,"\n//for Rim Effect\nvarying vec2 uvPosition;\n#include <surface_normal_varying_chunk>\nvarying vec3 vViewPosition;\n\nuniform vec3 rimColor;\nuniform float rimStrength;\nuniform float rimPow;\n\nuniform vec3 insideColor;\nuniform float insideStrength;\nuniform float insidePow;\n\n//original\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\n    //for Rim Effect\n    vec3 viewDir = normalize(vViewPosition);\n    float rimGlow = 1.0 - max(0.0, dot(surfaceNormal, viewDir));\n    rimGlow = pow(rimGlow, rimPow);\n    diffuseColor.rgb += rimColor * rimGlow * rimStrength;\n  \n    float insideGlow = max(0.0, dot(surfaceNormal, viewDir));\n    insideGlow = pow(insideGlow, insidePow);\n    diffuseColor.rgb += insideColor * insideGlow * insideStrength;\n    \n    #include <color_fragment> \n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t// modulation\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",e),this.uniforms=r.rDY.merge([d.getBasicUniforms(),u.getRimUniforms()]),this.initDefines()}static getRimUniforms(){return r.rDY.merge([{rimColor:{value:new r.Ilk(1,1,1)},rimStrength:{value:1},rimPow:{value:1},insideColor:{value:new r.Ilk(0,0,0)},insideStrength:{value:1},insidePow:{value:1}}])}initDefines(){super.initDefines(),this.defines.USE_SURFACE_NORMAL=!0}}class m{static initColorGUI(e,n,i="color"){const t={},r=n[i];return t[i]=r.getHex(),e.addColor(t,i).onChange((e=>{r.setHex(e)})),t}static initBasicMaterialGUI(e,n,i="Material"){const t=e.addFolder(i);return this.initMaterialFolder(t,n),t.open(),t}static initMaterialGUI(e,n,i="Material"){const t=this.initBasicMaterialGUI(e,n,i);this.initColorGUI(t,n,"emissive")}static initMaterialFolder(e,n){this.initColorGUI(e,n),e.add(n,"transparent"),e.add(n,"uniformOpacity",0,1)}static initSpriteMaterialGUI(e,n,i="Material"){const t=e.addFolder(i);this.initMaterialFolder(t,n),t.open()}static initGridMaterialGUI(e,n){this.initMaterialGUI(e,n);const i={mask:"",alphaMap:""},t=e.addFolder("WavyGridMaterial");return t.add(n,"isReversed"),t.add(n,"division",2,256).step(1),t.add(n,"divisionScaleX",0,4).step(1),t.add(i,"mask",{none:"",earth:"./textures/landmask.png"}).onChange((e=>{n.maskTexture=""===e?null:(new r.dpR).load(e)})),t.add(i,"alphaMap",{none:"",earth:"./textures/landmask.png"}).onChange((e=>{n.alphaMap=""===e?null:(new r.dpR).load(e)})),t.open(),t}static initWavyMaterialGUI(e,n){const i=this.initGridMaterialGUI(e,n).addFolder("WavyAnimation");i.add(n,"isAnimate"),i.add(n,"speed",-2,2),i.add(n,"waveFrequency",0,1),i.add(n,"wavePow",0,4),i.add(n,"direction",{horizontal:t.horizontal,vertical:t.vertical,radial:t.radial}),i.add(n,"raisedBottom",0,1),i.open()}static initAnimationGUI(e,n,i="Animation"){const t=e.addFolder(i);t.add(n,"isAnimate"),t.add(n,"speed",-2,2),t.open()}static initRimGUI(e,n,i="Rim Effect Material"){const t=e.addFolder(i);m.initColorGUI(t,n,"rimColor"),t.add(n,"rimStrength",0,4).step(.01),t.add(n,"rimPow",0,4).step(.01),m.initColorGUI(t,n,"insideColor"),t.add(n,"insideStrength",0,4).step(.01),t.add(n,"insidePow",0,8).step(.01),t.open()}static initExpansionGUI(e,n,i="ExpansionMaterial"){const t=e.addFolder("ExpansionMaterial");t.add(n,"expansionStrength",-12,12).step(.01),t.open()}static initFBMTilingGUI(e,n,i="FBM Tiling"){const t=e.addFolder("FBM Tiling");t.add(n,"tiles",1,8).step(1),t.add(n,"hashLoop",2,16).step(1),t.add(n,"amp",0,2).step(.01),t.open()}static initSkyGUI(e,n,i,t){const r={turbidity:10,rayleigh:.15,mieCoefficient:.005,mieDirectionalG:.8,inclination:.07,azimuth:.25,exposure:.75},a=4e5;function o(){const e=n.material.uniforms;e.turbidity.value=r.turbidity,e.rayleigh.value=r.rayleigh,e.mieCoefficient.value=r.mieCoefficient,e.mieDirectionalG.value=r.mieDirectionalG;const o=Math.PI*(r.inclination-.5),l=2*Math.PI*(r.azimuth-.5);i.position.x=a*Math.cos(l),i.position.y=a*Math.sin(l)*Math.sin(o),i.position.z=a*Math.sin(l)*Math.cos(o),e.sunPosition.value.copy(i.position),t.toneMappingExposure=r.exposure}o();const l=e.addFolder("Sky");l.add(r,"turbidity",1,20,.1).onChange(o),l.add(r,"rayleigh",0,4,.001).onChange(o),l.add(r,"mieCoefficient",0,.1,.001).onChange(o),l.add(r,"mieDirectionalG",0,1,.001).onChange(o),l.add(r,"inclination",0,1,1e-4).onChange(o),l.add(r,"azimuth",0,1,1e-4).onChange(o),l.add(r,"exposure",0,1,1e-4).onChange(o),l.open()}}var f=i(12),g=i(659);class p{static initScene(){return new r.xsS}static initLight(e){const n=new r.Mig(16777215,1);return e.add(n),n}static initCamera(e,n,i,t=400){const a=new r.cPb(45,n/i,1,t);return a.position.set(0,0,100),a.updateMatrixWorld(!1),e.add(a),a}static initControl(e,n){let i;null!=n&&(i=n.domElement);const t=new f.z(e,i);return t.update(),t}static initRenderer(e,n,i=0,t=!0){const a=new r.CP7({antialias:t});return a.setClearColor(new r.Ilk(i)),a.setSize(e,n),a.setPixelRatio(window.devicePixelRatio),document.body.appendChild(a.domElement),a}static initHelper(e){const n=new r.y8_(30);e.add(n)}static initSky(e,n,i){i.toneMapping=r.LY2;const t=new r.Kj0(new r.Aip(2e4,16,8),new r.vBJ({color:16777215}));t.position.y=-7e5,t.visible=!1,e.add(t);const a=new g.q;a.scale.setScalar(45e3),e.add(a),m.initSkyGUI(n,a,t,i)}}var _=i(899);class h{constructor(){const e=p.initScene();e.fog=new r.ybr(0,80,160),p.initLight(e);const n=p.initCamera(e,1280,640),i=p.initRenderer(1280,640);p.initControl(n,i),p.initHelper(e);const t=this.initObject(e);c.Fz.on(c.M9.tick,(t=>{i.render(e,n)})),this.initGUI(t)}initObject(e){const n=new r.DvJ(20,20,20),i=new r.m_w(6,6,20,32),t=new r.XvJ(12,6,32,32),a=new u({fog:void 0!==e.fog});a.uniformOpacity=.65,a.color=new r.Ilk(13073),a.rimColor=new r.Ilk(3359744),a.insideColor=new r.Ilk(0),a.rimPow=2,a.insidePow=6,a.insideStrength=.5,a.transparent=!0;const o=new r.Kj0(n,a);o.position.x=-40;const l=new r.Kj0(t,a),s=new r.Kj0(i,a);return s.position.x=40,e.add(o,l,s),a}initGUI(e){const n=new _.ZP;m.initBasicMaterialGUI(n,e),m.initRimGUI(n,e)}}window.onload=()=>{new h}}},i={};function t(e){var r=i[e];if(void 0!==r)return r.exports;var a=i[e]={exports:{}};return n[e](a,a.exports,t),a.exports}t.m=n,e=[],t.O=(n,i,r,a)=>{if(!i){var o=1/0;for(c=0;c<e.length;c++){for(var[i,r,a]=e[c],l=!0,s=0;s<i.length;s++)(!1&a||o>=a)&&Object.keys(t.O).every((e=>t.O[e](i[s])))?i.splice(s--,1):(l=!1,a<o&&(o=a));if(l){e.splice(c--,1);var d=r();void 0!==d&&(n=d)}}return n}a=a||0;for(var c=e.length;c>0&&e[c-1][2]>a;c--)e[c]=e[c-1];e[c]=[i,r,a]},t.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return t.d(n,{a:n}),n},t.d=(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),t.j=66,(()=>{var e={66:0};t.O.j=n=>0===e[n];var n=(n,i)=>{var r,a,[o,l,s]=i,d=0;if(o.some((n=>0!==e[n]))){for(r in l)t.o(l,r)&&(t.m[r]=l[r]);if(s)var c=s(t)}for(n&&n(i);d<o.length;d++)a=o[d],t.o(e,a)&&e[a]&&e[a][0](),e[a]=0;return t.O(c)},i=self.webpackChunkthreejs_shader_materials=self.webpackChunkthreejs_shader_materials||[];i.forEach(n.bind(null,0)),i.push=n.bind(null,i.push.bind(i))})();var r=t.O(void 0,[736],(()=>t(672)));r=t.O(r)})();