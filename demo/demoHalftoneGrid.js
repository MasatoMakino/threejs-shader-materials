(()=>{"use strict";var n,e={518:(n,e,i)=>{var t=i(6709),a=i(8012),r=i(1659),s=i(678);class o{static initColorGUI(n,e,i="color"){const t={},a=e[i];return t[i]=a.getHex(),n.addColor(t,i).onChange((n=>{a.setHex(n)})),t}static initMaterialGUI(n,e,i="Material"){const t=n.addFolder(i);this.initMaterialFolder(t,e),this.initColorGUI(t,e,"emissive"),t.open()}static initMaterialFolder(n,e){this.initColorGUI(n,e),n.add(e,"transparent"),n.add(e,"uniformOpacity",0,1)}static initSpriteMaterialGUI(n,e,i="Material"){const t=n.addFolder(i);this.initMaterialFolder(t,e),t.open()}static initGridMaterialGUI(n,e){this.initMaterialGUI(n,e);const i={mask:"",alphaMap:""},a=n.addFolder("WavyGridMaterial");return a.add(e,"isReversed"),a.add(e,"division",2,256).step(1),a.add(e,"divisionScaleX",0,4).step(1),a.add(i,"mask",{none:"",earth:"./textures/landmask.png"}).onChange((n=>{e.maskTexture=""===n?null:(new t.TextureLoader).load(n)})),a.add(i,"alphaMap",{none:"",earth:"./textures/landmask.png"}).onChange((n=>{e.alphaMap=""===n?null:(new t.TextureLoader).load(n)})),a.open(),a}static initWavyMaterialGUI(n,e){const i=this.initGridMaterialGUI(n,e).addFolder("WavyAnimation");i.add(e,"isAnimate"),i.add(e,"speed",-2,2),i.add(e,"waveFrequency",0,1),i.add(e,"wavePow",0,4),i.add(e,"direction",{horizontal:s.Directions.horizontal,vertical:s.Directions.vertical,radial:s.Directions.radial}),i.add(e,"raisedBottom",0,1),i.open()}static initAnimationGUI(n,e,i="Animation"){const t=n.addFolder(i);t.add(e,"isAnimate"),t.add(e,"speed",-2,2),t.open()}static initRimGUI(n,e,i="Rim Effect Material"){const t=n.addFolder(i);o.initColorGUI(t,e,"rimColor"),t.add(e,"rimStrength",0,4).step(.01),t.add(e,"rimPow",0,4).step(.01),o.initColorGUI(t,e,"insideColor"),t.add(e,"insideStrength",0,4).step(.01),t.add(e,"insidePow",0,8).step(.01),t.open()}static initExpansionGUI(n,e,i="ExpansionMaterial"){const t=n.addFolder("ExpansionMaterial");t.add(e,"expansionStrength",-12,12).step(.01),t.open()}static initFBMTilingGUI(n,e,i="FBM Tiling"){const t=n.addFolder("FBM Tiling");t.add(e,"tiles",1,8).step(1),t.add(e,"hashLoop",2,16).step(1),t.add(e,"amp",0,2).step(.01),t.open()}static initSkyGUI(n,e,i,t){const a={turbidity:10,rayleigh:.15,mieCoefficient:.005,mieDirectionalG:.8,inclination:.07,azimuth:.25,exposure:.75},r=4e5;function s(){const n=e.material.uniforms;n.turbidity.value=a.turbidity,n.rayleigh.value=a.rayleigh,n.mieCoefficient.value=a.mieCoefficient,n.mieDirectionalG.value=a.mieDirectionalG;const s=Math.PI*(a.inclination-.5),o=2*Math.PI*(a.azimuth-.5);i.position.x=r*Math.cos(o),i.position.y=r*Math.sin(o)*Math.sin(s),i.position.z=r*Math.sin(o)*Math.cos(s),n.sunPosition.value.copy(i.position),t.toneMappingExposure=a.exposure}s();const o=n.addFolder("Sky");o.add(a,"turbidity",1,20,.1).onChange(s),o.add(a,"rayleigh",0,4,.001).onChange(s),o.add(a,"mieCoefficient",0,.1,.001).onChange(s),o.add(a,"mieDirectionalG",0,1,.001).onChange(s),o.add(a,"inclination",0,1,1e-4).onChange(s),o.add(a,"azimuth",0,1,1e-4).onChange(s),o.add(a,"exposure",0,1,1e-4).onChange(s),o.open()}}class u{static initScene(){return new t.Scene}static initLight(n){const e=new t.AmbientLight(16777215,1);return n.add(e),e}static initCamera(n,e,i,a=400){const r=new t.PerspectiveCamera(45,e/i,1,a);return r.position.set(0,0,100),r.updateMatrixWorld(!1),n.add(r),r}static initControl(n,e){let i;null!=e&&(i=e.domElement);const t=new a.z(n,i);return t.update(),t}static initRenderer(n,e,i=0,a="webgl-canvas",r=!0){const s=document.getElementById(a);s.style.zIndex=0,s.style.position="absolute";const o=new t.WebGLRenderer({canvas:s,antialias:r});return o.setClearColor(new t.Color(i)),o.setSize(n,e),o.setPixelRatio(window.devicePixelRatio),o}static initHelper(n){const e=new t.AxesHelper(30);n.add(e)}static initSky(n,e,i){i.toneMapping=t.ACESFilmicToneMapping;const a=new t.Mesh(new t.SphereBufferGeometry(2e4,16,8),new t.MeshBasicMaterial({color:16777215}));a.position.y=-7e5,a.visible=!1,n.add(a);const s=new r.q;s.scale.setScalar(45e3),n.add(s),o.initSkyGUI(e,s,a,i)}}var l=i(8694),m=i(5732),c=i(8464),d=i(4027);class g{constructor(){const n=u.initScene();n.fog=new t.Fog(0,80,160),u.initLight(n);const e=u.initCamera(n,640,480),i=u.initRenderer(640,480);u.initControl(e,i),u.initHelper(n);const a=this.initObject(n);d.RAFTicker.addEventListener(d.RAFTickerEventType.tick,(t=>{i.render(n,e)})),this.initGUI(a)}initObject(n){const e=new t.PointLight(16777215,1,0,2);e.position.set(10,20,30),n.add(e);const i=new t.PointLightHelper(e);n.add(i);const a=new t.SphereGeometry(10,64,64),r=new m.HalftoneGridMaterial({fog:void 0!==n.fog});r.color=new t.Color(16737894),r.direction=c.Directions.vertical;const s=new t.Mesh(a,r);return n.add(s),r}initGUI(n){const e=new l.XS;o.initWavyMaterialGUI(e,n),this.initGUIMaterial(e,n)}initGUIMaterial(n,e){const i=n.addFolder("HalftoneMaterial");i.add(e,"radius",0,1),i.open()}}window.onload=()=>{new g}},5072:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.GridMaterial=void 0;const t=i(6709),a=i(4928),r=i(4586),s=i(7405);class o extends a.ShaderPhongMaterial{get division(){return this.uniforms.division.value}set division(n){this.uniforms.division.value=n}get divisionScaleX(){return this.uniforms.divisionScaleX.value}set divisionScaleX(n){this.uniforms.divisionScaleX.value=n}get isReversed(){return this.uniforms.isReversed.value}set isReversed(n){this.uniforms.isReversed.value=n}get maskTexture(){return s.MaskMapChunk.getMaskTexture(this)}set maskTexture(n){s.MaskMapChunk.setMaskTexture(this,n)}initChunks(){super.initChunks(),s.MaskMapChunk.registerChunk(),r.ReversibleChunk.registerChunk()}static getBasicUniforms(){return t.UniformsUtils.merge([a.ShaderPhongMaterial.getBasicUniforms(),r.ReversibleChunk.getUniform(),s.MaskMapChunk.getUniform()])}initDefaultSetting(n){super.initDefaultSetting(n),null==n.transparent&&(this.transparent=!0)}}e.GridMaterial=o},8719:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},4928:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.ShaderPhongMaterial=void 0;const a=i(6709),r=i(2015),s=i(7852),o=i(4215),u=i(9712),l=t(i(8719)),m=t(i(3844));class c extends a.ShaderMaterial{constructor(n,e,i){super(i),this._opacity=1,null!=i||(i={}),null!=n||(n=(0,m.default)()),null!=e||(e=(0,l.default)()),this.initChunks(),this.initUniforms(),this.initDefines(),this.vertexShader=n,this.fragmentShader=e,this.initDefaultSetting(i)}static getBasicUniforms(){return a.UniformsUtils.merge([a.UniformsLib.common,a.UniformsLib.specularmap,a.UniformsLib.envmap,a.UniformsLib.aomap,a.UniformsLib.lightmap,a.UniformsLib.emissivemap,a.UniformsLib.bumpmap,a.UniformsLib.normalmap,a.UniformsLib.displacementmap,a.UniformsLib.gradientmap,a.UniformsLib.fog,a.UniformsLib.lights,{emissive:{value:new a.Color(0)},specular:{value:new a.Color(1118481)},shininess:{value:30},hasAlphaMap:{value:!1}},u.SurfaceNormalChunk.getUniform(),r.ExpansionChunk.getUniform(),s.MapChunk.getUniform()])}initChunks(){o.MeshPhongChunk.registerChunk(),u.SurfaceNormalChunk.registerChunk(),r.ExpansionChunk.registerChunk(),s.MapChunk.registerChunk()}initUniforms(){this.uniforms=a.UniformsUtils.merge([c.getBasicUniforms(),r.ExpansionChunk.getUniform(),{}])}initDefines(){this.defines=Object.assign({},o.MeshPhongChunk.getDefines(),u.SurfaceNormalChunk.getDefines(),r.ExpansionChunk.getDefines(),this.defines)}initDefaultSetting(n){this.uniformOpacity=this._opacity,this.lights=!0}get color(){return this.uniforms.diffuse.value}set color(n){this.uniforms.diffuse.value=n}get opacity(){return this.uniformOpacity}get uniformOpacity(){return this._opacity}set opacity(n){this.uniformOpacity=n}set uniformOpacity(n){var e;this._opacity=n,(null===(e=this.uniforms)||void 0===e?void 0:e.opacity)&&(this.uniforms.opacity.value=n)}get emissive(){return this.uniforms.emissive.value}set emissive(n){this.uniforms.emissive.value=n}get map(){return s.MapChunk.getMap(this)}set map(n){s.MapChunk.setMap(this,n),this.onSetMap(n)}onSetMap(n){}get alphaMap(){return this.uniforms.alphaMap.value}set alphaMap(n){this.uniforms.alphaMap.value=n,this.uniforms.hasAlphaMap.value=null!=n,this.onSetAlphaMap(n)}onSetAlphaMap(n){}startGlow(){this.alphaTest=0,this.depthWrite=!1,this.blending=a.AdditiveBlending}}e.ShaderPhongMaterial=c},3844:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\nvarying vec3 vViewPosition;\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n#include <surface_normal_varying_chunk>\n#include <__expansion_uniform_chunk>\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n    #include <mesh_position_vertex>\n    uvPosition = uv;\n\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n    \n    #include <beginnormal_vertex>\n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <surface_normal_vertex_chunk>\n    #include <normal_vertex>\n    \n    #include <begin_vertex>\n    \n    #include <__expansion_vertex_chunk>\n    \n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n    \n    vViewPosition = - mvPosition.xyz;\n\n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n}\n"},8743:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#include <sprite_fragment_uniform_chunk>\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n    #include <clipping_planes_fragment>\n    #include <sprite_diffuse_color_chunk>\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n    outgoingLight = diffuseColor.rgb;\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"},3477:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.ShaderSpriteMaterial=void 0;const a=i(6709),r=i(4592),s=t(i(8743)),o=t(i(5544));class u extends a.ShaderMaterial{constructor(n,e,i){super(i),this._opacity=1,null!=i||(i={}),null!=n||(n=(0,o.default)()),null!=e||(e=(0,s.default)()),this.initChunks(),this.initUniforms(),this.initDefines(),this.vertexShader=n,this.fragmentShader=e,this.initDefaultSetting(i)}initChunks(){r.SpriteChunk.registerChunk()}initUniforms(){this.uniforms=a.UniformsUtils.merge([r.SpriteChunk.getUniform(),{}])}initDefines(){this.defines=Object.assign({},r.SpriteChunk.getDefines(),this.defines)}initDefaultSetting(n){this.uniformOpacity=this._opacity}get opacity(){return this._opacity}get uniformOpacity(){return this._opacity}set opacity(n){this.uniformOpacity=n}set uniformOpacity(n){var e;this._opacity=n,(null===(e=this.uniforms)||void 0===e?void 0:e.opacity)&&(this.uniforms.opacity.value=n)}get color(){return this.uniforms.diffuse.value}set color(n){this.uniforms.diffuse.value=n}get center(){return this.uniforms.center.value}set center(n){this.uniforms.center.value=n}get rotation(){return this.uniforms.rotation.value}set rotation(n){this.uniforms.rotation.value=n}get uvTransform(){return this.uniforms.uvTransform.value}set uvTransform(n){this.uniforms.uvTransform.value=n}get map(){return this.uniforms.map.value}set map(n){this.uniforms.map.value=n}}e.ShaderSpriteMaterial=u},5544:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#include <sprite_vertex_uniform_chunk>\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\t#include <uv_vertex>\n\t#include <sprite_mv_position_chunk>\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n"},6823:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.WavyGridMaterial=void 0;const t=i(4027),a=i(6709),r=i(3467),s=i(7405),o=i(4586),u=i(8464),l=i(5072);class m extends l.GridMaterial{constructor(n,e,i){super(n,e,i),this.speed=-.5,this.animationListener=n=>{this.addTime(n.delta/1e3)},this.isAnimate=this.isAnimate}addTime(n){r.AnimationChunk.addTime(this,n)}get isAnimate(){return this.uniforms.isAnimate.value}set isAnimate(n){this.uniforms.isAnimate.value=n,this.isAnimate?this.startAnimation():this.stopAnimation()}get waveFrequency(){return this.uniforms.waveFrequency.value}set waveFrequency(n){this.uniforms.waveFrequency.value=n}get wavePow(){return this.uniforms.wavePow.value}set wavePow(n){this.uniforms.wavePow.value=n}get raisedBottom(){return this.uniforms.raisedBottom.value}set raisedBottom(n){this.uniforms.raisedBottom.value=n}get direction(){return this.uniforms.direction.value}set direction(n){this.uniforms.direction.value=n}initChunks(){super.initChunks(),u.WavyAnimationChunk.registerChunk()}static getBasicUniforms(){return a.UniformsUtils.merge([super.getBasicUniforms(),o.ReversibleChunk.getUniform(),u.WavyAnimationChunk.getUniform(),s.MaskMapChunk.getUniform()])}initDefaultSetting(n){super.initDefaultSetting(n)}startAnimation(){t.RAFTicker.on(t.RAFTickerEventType.onBeforeTick,this.animationListener)}stopAnimation(){t.RAFTicker.off(t.RAFTickerEventType.onBeforeTick,this.animationListener)}}e.WavyGridMaterial=m},2580:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\nuniform float grid;\nuniform float divisionScaleX;\n#include <time_animation_uniform_chunk>\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvec2 rand2D(vec2 p, vec2 scale) {\n    p = mod(p, scale);\n    const float a = 12.9898, b = 78.233, c = 43758.5453;\n    const float a2 = 26.7, b2 = 14.879;\n    \n    highp float dt = dot(p, vec2(a, b)), sn = mod(dt, PI);\n    highp float dt2 = dot(p, vec2(a2, b2)), sn2 = mod(dt2, PI);\n    return fract(sin(vec2(dt, dt2)) * c);\n}\n\n/*!\n * Cellular Noise\n *\n * The inherits function is :\n * Author : patriciogv\n * see https://thebookofshaders.com/12/\n * LICENSE : https://github.com/patriciogonzalezvivo/thebookofshaders/issues/235\n */\nfloat cellularNoise(vec2 uv, float grid, float divisionScaleX, float time){\n  \n    vec2 scale = grid * vec2 ( divisionScaleX, 1.0 );\n    uv *= scale;\n    \n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n    \n    float minDist = 1.;\n    \n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 point = rand2D(i_uv + neighbor, scale);\n            \n            point = 0.5 + 0.5 * sin(time + PI2 * point);\n            \n            vec2 diff = neighbor + point - f_uv;\n            float dist = length(diff);\n            \n            minDist = min(minDist, dist);\n        }\n    }\n    \n    return minDist;\n}\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n\n    float dist = cellularNoise( mapUV, grid, divisionScaleX, time );\n    diffuseColor.rgb *= dist;\n    diffuseColor.a *= dist;\n    \n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},9366:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.CellularNoiseMaterial=void 0;const a=i(4027),r=i(6709),s=i(678),o=t(i(2580));class u extends s.ShaderPhongMaterial{constructor(n){super(null,(0,o.default)(),n),this.speed=-.02,this.animationListener=n=>{this.addTime(n.delta/1e3)},this.isAnimate=this.isAnimate}addTime(n){this.isAnimate&&s.AnimationChunk.addTime(this,n)}get isAnimate(){return this.uniforms.isAnimate.value}set isAnimate(n){this.uniforms.isAnimate.value=n,this.isAnimate?this.startAnimation():this.stopAnimation()}get grid(){return this.uniforms.grid.value}set grid(n){this.uniforms.grid.value=n}get divisionScaleX(){return this.uniforms.divisionScaleX.value}set divisionScaleX(n){this.uniforms.divisionScaleX.value=n}initChunks(){super.initChunks(),s.AnimationChunk.registerChunk()}initUniforms(){this.uniforms=r.UniformsUtils.merge([s.ShaderPhongMaterial.getBasicUniforms(),s.AnimationChunk.getUniform(),{grid:{value:3},divisionScaleX:{value:1}}])}startAnimation(){a.RAFTicker.on(a.RAFTickerEventType.onBeforeTick,this.animationListener)}stopAnimation(){a.RAFTicker.off(a.RAFTickerEventType.onBeforeTick,this.animationListener)}}e.CellularNoiseMaterial=u},3467:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.AnimationChunk=void 0;const t=i(2638);class a extends t.GLSLChunk{static registerChunk(){r.registerChunk()}static getUniform(){return{time:{value:0},isAnimate:{value:!0}}}static addTime(n,e){n.uniforms.time.value+=e*n.speed}}e.AnimationChunk=a;class r extends t.GLSLChunk{static getChunkName(){return"time_animation_uniform_chunk"}static getChunk(){return"\n    uniform float time;\n    uniform bool isAnimate;\n    "}}},2015:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ExpansionVertexChunk=e.ExpansionUniformChunk=e.ExpansionChunk=void 0;const t=i(2638);class a extends t.GLSLChunk{static registerChunk(){r.registerChunk(),s.registerChunk()}static getDefines(){return{USE_EXPANSION:!1}}static getUniform(){return{expansionStrength:{value:0}}}}e.ExpansionChunk=a;class r extends t.GLSLChunk{static getChunkName(){return"__expansion_uniform_chunk"}static getChunk(){return"\n    #ifdef USE_EXPANSION\n      uniform float expansionStrength;\n    #endif\n    "}}e.ExpansionUniformChunk=r;class s extends t.GLSLChunk{static getChunkName(){return"__expansion_vertex_chunk"}static getChunk(){return"\n    #ifdef USE_EXPANSION\n      transformed += normal * expansionStrength;\n    #endif\n    "}}e.ExpansionVertexChunk=s},2638:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.GLSLChunk=void 0;const t=i(6709);e.GLSLChunk=class{static getChunkName(){return""}static getChunk(){return""}static getDefines(){return{}}static registerChunk(){t.ShaderChunk&&null==t.ShaderChunk[this.getChunkName()]&&(t.ShaderChunk[this.getChunkName()]=this.getChunk())}static getUniform(){return{}}}},5867:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.HexGridChunk=void 0;const t=i(2638);class a extends t.GLSLChunk{static registerChunk(){super.registerChunk(),r.registerChunk()}}e.HexGridChunk=a;class r extends t.GLSLChunk{static getChunkName(){return"hex_grid_function_chunk"}static getChunk(){return"\n    /**\n     * ヘックスの縁までの距離を取得する。\n     */\n    float hexDist(vec2 p)\n    {\n        p = abs(p);\n        float d = dot(p, normalize(vec2(1.0, 1.73)));\n        return max(d, p.x);\n    }\n    \n    /**\n     * uv座標からヘックス固有のxy座標とIDを取得する\n     *\n     * x : ヘックスの中心点からの回転角\n     * y : ヘックスの縁までの距離\n     * zw : ヘックスのID\n     */\n    vec4 hexCoords(vec2 uv)\n    {\n        vec2 r = vec2(1.0, 1.73);\n        vec2 h = r * 0.5;\n        vec2 a = mod(uv, r) - h;\n        vec2 b = mod(uv - h, r) - h;\n    \n        vec2 gv = length(a) < length(b) ? a : b;\n        vec2 id = uv - gv;\n    \n        float x = atan(gv.x, gv.y);\n        float y = 0.5 - hexDist(gv);\n    \n        return vec4(x, y, id);\n    }\n    "}}},7852:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.MapChunk=void 0;const t=i(6709),a=i(2638);class r extends a.GLSLChunk{static registerChunk(){super.registerChunk(),s.registerChunk(),o.registerChunk(),u.registerChunk()}static getUniform(){return t.UniformsUtils.merge([super.getUniform(),{hasMap:{value:!1},map:{value:null}}])}static getMap(n){return n.uniforms.map.value}static setMap(n,e){n.uniforms.map.value=e,n.uniforms.hasMap.value=null!=e}}e.MapChunk=r;class s extends a.GLSLChunk{static getChunkName(){return"map_uniform_chunk"}static getChunk(){return"\n      uniform bool hasMap;\n      uniform sampler2D map;\n    "}}class o extends a.GLSLChunk{static getChunkName(){return"map_fragment_chunk"}static getChunk(){return"\n      if( hasMap ){\n        vec4 texelColor = texture2D( map, mapUV );\n        diffuseColor *= texelColor;\n      }\n    "}}class u extends a.GLSLChunk{static getChunkName(){return"__ShaderMaterial__map_fragment_begin_chunk"}static getChunk(){return"\n      vec2 mapUV = uvPosition;\n    "}}},7405:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.MaskMapChunk=void 0;const t=i(6709),a=i(2638),r=i(7500);class s extends r.RepeatPatternChunk{static registerChunk(){super.registerChunk(),o.registerChunk(),u.registerChunk()}static getUniform(){return t.UniformsUtils.merge([super.getUniform(),{hasMaskTexture:{value:!1},maskTexture:{value:null}}])}static getMaskTexture(n){return n.uniforms.maskTexture.value}static setMaskTexture(n,e){n.uniforms.maskTexture.value=e,n.uniforms.hasMaskTexture.value=null!=e}}e.MaskMapChunk=s;class o extends a.GLSLChunk{static getChunkName(){return"mask_map_uniform_chunk"}static getChunk(){return"\n      uniform bool hasMaskTexture;\n      uniform sampler2D maskTexture;\n    "}}class u extends a.GLSLChunk{static getChunkName(){return"mask_map_fragment_chunk"}static getChunk(){return"\n      float mask = 1.0;\n      if( hasMaskTexture ){\n        vec2 uVm = id / vec2( division * divisionScaleX, division);\n        mask = texture2D( maskTexture, uVm ).g;\n      }\n    "}}},4215:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.MeshPhongChunk=void 0;const t=i(2638);class a extends t.GLSLChunk{static registerChunk(){r.registerChunk(),s.registerChunk(),o.registerChunk(),u.registerChunk(),l.registerChunk()}static getDefines(){return{USE_MESH_POSITION:!1}}}e.MeshPhongChunk=a;class r extends t.GLSLChunk{static getChunkName(){return"mesh_phong_uniform"}static getChunk(){return"\n      uniform vec3 diffuse;\n      uniform vec3 emissive;\n      uniform vec3 specular;\n      uniform float shininess;\n      uniform float opacity;\n      uniform bool hasAlphaMap;\n      uniform sampler2D alphaMap;\n    "}}class s extends t.GLSLChunk{static getChunkName(){return"mesh_phong_diffuse_color"}static getChunk(){return"\n      vec4 diffuseColor = vec4( diffuse, opacity );\n      ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n      vec3 totalEmissiveRadiance = emissive;\n    "}}class o extends t.GLSLChunk{static getChunkName(){return"mesh_phong_switching_alpha_map"}static getChunk(){return"\n      if( hasAlphaMap ){\n        diffuseColor.a *= texture2D( alphaMap, mapUV ).g;\n      }\n    "}}class u extends t.GLSLChunk{static getChunkName(){return"mesh_position_varying"}static getChunk(){return"\n    #ifdef USE_MESH_POSITION\n    varying vec3 meshPosition;\n    #endif\n    "}}class l extends t.GLSLChunk{static getChunkName(){return"mesh_position_vertex"}static getChunk(){return"\n    #ifdef USE_MESH_POSITION\n    meshPosition = position;\n    #endif\n    "}}},7500:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.RepeatPatternChunk=void 0;const t=i(2638);class a extends t.GLSLChunk{static registerChunk(){r.registerChunk(),s.registerChunk()}static getUniform(){return{division:{value:32},divisionScaleX:{value:1}}}}e.RepeatPatternChunk=a;class r extends t.GLSLChunk{static getChunkName(){return"repeat_pattern_uniform_chunk"}static getChunk(){return"\n      uniform float division;\n      uniform float divisionScaleX;\n    "}}class s extends t.GLSLChunk{static getChunkName(){return"repeat_pattern_fragment_chunk"}static getChunk(){return"\n      vec2 uv =\n        uvPosition\n        * vec2( division * divisionScaleX, division);\n    "}}},4586:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ReversibleChunk=void 0;const t=i(2638);class a extends t.GLSLChunk{static registerChunk(){r.registerChunk()}static getUniform(){return{isReversed:{value:!1}}}}e.ReversibleChunk=a;class r extends t.GLSLChunk{static getChunkName(){return"reversible_uniform_chunk"}static getChunk(){return"\n      uniform bool isReversed;\n    "}}},4592:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.SpriteChunk=void 0;const t=i(2638),a=i(6709),r=i(6709);class s extends t.GLSLChunk{static registerChunk(){o.registerChunk(),u.registerChunk(),l.registerChunk(),m.registerChunk()}static getDefines(){return{USE_SIZEATTENUATION:!0}}static getUniform(){return a.UniformsUtils.merge([r.UniformsLib.sprite,r.UniformsLib.fog,r.UniformsLib.lights])}}e.SpriteChunk=s;class o extends t.GLSLChunk{static getChunkName(){return"sprite_vertex_uniform_chunk"}static getChunk(){return"\n      uniform float rotation;\n      uniform vec2 center;\n    "}}class u extends t.GLSLChunk{static getChunkName(){return"sprite_fragment_uniform_chunk"}static getChunk(){return"\n      uniform vec3 diffuse;\n      uniform float opacity;\n    "}}class l extends t.GLSLChunk{static getChunkName(){return"sprite_diffuse_color_chunk"}static getChunk(){return"\n      vec3 outgoingLight = vec3( 0.0 );\n      vec4 diffuseColor = vec4( diffuse, opacity );\n    "}}class m extends t.GLSLChunk{static getChunkName(){return"sprite_mv_position_chunk"}static getChunk(){return"\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n    "}}},9712:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.SurfaceNormalVertexChunk=e.SurfaceNormalVaryingChunk=e.SurfaceNormalChunk=void 0;const t=i(2638);class a extends t.GLSLChunk{static registerChunk(){r.registerChunk(),s.registerChunk()}static getDefines(){return{USE_SURFACE_NORMAL:!1}}static getUniform(){return{}}}e.SurfaceNormalChunk=a;class r extends t.GLSLChunk{static getChunkName(){return"surface_normal_varying_chunk"}static getChunk(){return"\n    #ifdef USE_SURFACE_NORMAL\n      varying vec3 surfaceNormal;\n    #endif\n    "}}e.SurfaceNormalVaryingChunk=r;class s extends t.GLSLChunk{static getChunkName(){return"surface_normal_vertex_chunk"}static getChunk(){return"\n    #ifdef USE_SURFACE_NORMAL\n      surfaceNormal = normalize( transformedNormal );\n    #endif\n    "}}e.SurfaceNormalVertexChunk=s},6905:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TilingFBMChunk=void 0;const t=i(2638);class a extends t.GLSLChunk{static registerChunk(){r.registerChunk(),s.registerChunk()}static getUniform(){return{tiles:{value:2},hashLoop:{value:8},amp:{value:.5}}}static getDefines(){return{NUM_OCTAVES:3}}}e.TilingFBMChunk=a;class r extends t.GLSLChunk{static getChunkName(){return"tiling_fbm_function_chunk"}static getChunk(){return"\n        // Based On Dave_Hoskins \n        // https://www.shadertoy.com/view/4dlGW2\n        \n        float hash(in vec2 p, in float hashLoop)\n        {\n            p = mod(p, hashLoop);\n            return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\n        }\n        \n        float noise(in vec2 p, in float hashLoop)\n        {\n            p *= hashLoop;\n            vec2 f = fract(p);\n            vec2 u = f*f*(3.0-2.0*f);\n        \n            p = floor(p);\n            float a = hash(p, hashLoop);\n            float b = hash(p + vec2(1.0, 0.0), hashLoop);\n            float c = hash(p + vec2(0.0, 1.0), hashLoop);\n            float d = hash(p + vec2(1.0, 1.0), hashLoop);\n        \n            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n        }\n        \n        // Based On Dave_Hoskins \n        // https://www.shadertoy.com/view/4dlGW2\n        \n        float fbm(in vec2 p)\n        {\n            float v = 0.0;\n            \n            p = mod(p, hashLoop);\n            float a = amp;\n            float hashLoopVal = hashLoop;\n            \n            for (int i = 0; i < NUM_OCTAVES; i++){\n                v += noise(p, hashLoopVal) * a;\n                a *= .5;\n                hashLoopVal *= 2.0;\n            }\n            return v;\n        }\n    "}}class s extends t.GLSLChunk{static getChunkName(){return"tiling_fbm_uniform_chunk"}static getChunk(){return"\n      uniform float tiles;  \n      uniform float hashLoop;\n      uniform float amp;\n    "}}},8464:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Directions=e.WavyAnimationChunk=void 0;const t=i(2638),a=i(6709),r=i(3467);class s extends r.AnimationChunk{static registerChunk(){super.registerChunk(),o.registerChunk(),u.registerChunk()}static getUniform(){return a.UniformsUtils.merge([super.getUniform(),{raisedBottom:{value:.05},waveFrequency:{value:.2},wavePow:{value:4},direction:{value:l.vertical}}])}}e.WavyAnimationChunk=s;class o extends t.GLSLChunk{static getChunkName(){return"wavy_animation_fragment_chunk"}static getChunk(){return`\n    float distance = id.y;\n    if( direction == ${l.horizontal}){\n      distance = id.x;\n    }else if( direction == ${l.radial} ){\n      distance = length(id.xy);\n    }\n\n    float wavy = isAnimate\n      ? pow( sin( (distance * waveFrequency - time) ), wavePow) + raisedBottom\n      : 1.0;\n  \n    diffuseColor.a *= wavy;\n    `}}class u extends t.GLSLChunk{static getChunkName(){return"wavy_animation_uniform_chunk"}static getChunk(){return"\n    uniform float raisedBottom;\n    uniform float waveFrequency;\n    uniform float wavePow;\n    uniform int direction;\n    "}}var l;!function(n){n[n.vertical=4]="vertical",n[n.horizontal=3]="horizontal",n[n.radial=5]="radial"}(l=e.Directions||(e.Directions={}))},4711:function(n,e,i){var t=this&&this.__createBinding||(Object.create?function(n,e,i,t){void 0===t&&(t=i),Object.defineProperty(n,t,{enumerable:!0,get:function(){return e[i]}})}:function(n,e,i,t){void 0===t&&(t=i),n[t]=e[i]}),a=this&&this.__exportStar||function(n,e){for(var i in n)"default"===i||Object.prototype.hasOwnProperty.call(e,i)||t(e,n,i)};Object.defineProperty(e,"__esModule",{value:!0}),a(i(3467),e),a(i(2015),e),a(i(2638),e),a(i(5867),e),a(i(7852),e),a(i(7405),e),a(i(4215),e),a(i(7500),e),a(i(4586),e),a(i(4592),e),a(i(9712),e),a(i(6905),e),a(i(8464),e)},3629:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\nuniform float bottom;\nuniform float top;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #ifdef USE_MAP\n      float mapY = ( meshPosition.y - bottom ) / ( top - bottom );\n      vec4 texelColor = texture2D( map, vec2(0.5, mapY) );\n      texelColor = mapTexelToLinear( texelColor );\n      diffuseColor *= texelColor;\n    #endif\n    #include <color_fragment>\n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},4322:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.ContourMaterial=void 0;const a=i(6709),r=i(4928),s=t(i(3629)),o=t(i(3844));class u extends r.ShaderPhongMaterial{constructor(n){super((0,o.default)(),(0,s.default)(),n)}get map(){return this._map}loadMap(n,e){this._map=(new a.TextureLoader).load(n,(n=>{this.uniforms&&this.uniforms.map&&(this.uniforms.map.value=n)})),e.computeBoundingBox(),this.uniforms.top.value=e.boundingBox.max.y,this.uniforms.bottom.value=e.boundingBox.min.y}initDefines(){super.initDefines(),this.defines.USE_MESH_POSITION=!0}initUniforms(){this.uniforms=a.UniformsUtils.merge([r.ShaderPhongMaterial.getBasicUniforms(),{top:{value:1},bottom:{value:-1}}])}initDefaultSetting(n){super.initDefaultSetting(n),null==n.transparent?this.transparent=!0:this.transparent=n.transparent,this.transparent&&null==n.alphaTest&&(this.alphaTest=.5),null==n.side?this.side=a.DoubleSide:this.side=n.side}}e.ContourMaterial=u},3227:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n//user settings\n#include <time_animation_uniform_chunk>\n#include <wavy_animation_uniform_chunk>\n#include <repeat_pattern_uniform_chunk>\n#include <mask_map_uniform_chunk>\n#include <reversible_uniform_chunk>\nuniform float gridWeight;\nuniform float radius;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n\n    #include <repeat_pattern_fragment_chunk>    \n    vec2 localPos = mod(uv, 1.0) - 0.5;\n    vec2 id = uv - localPos;\n    #include <wavy_animation_fragment_chunk>\n\n    #include <mask_map_fragment_chunk>\n    float w = gridWeight;\n    w = clamp( w, 0.0, 1.0);\n    \n    float margin = clamp ( w * 0.33, 0.00, 0.05 );\n    \n    //十字を描画\n    float gridLine;\n    gridLine  = smoothstep ( -w-margin, -w, localPos.x );\n    gridLine -= smoothstep ( w, w+margin, localPos.x );\n    gridLine += smoothstep ( -w-margin, -w, localPos.y );\n    gridLine -= smoothstep ( w, w+margin, localPos.y );\n    gridLine  = clamp( gridLine, 0.0, 1.0 ); \n\n    //半径でマスク\n    float r = radius - (1.0-mask);\n    gridLine -= smoothstep( r, r+margin, localPos.x);\n    gridLine -= smoothstep( -r, -r-margin, localPos.x);\n    gridLine -= smoothstep( r, r+margin, localPos.y);\n    gridLine -= smoothstep( -r, -r-margin, localPos.y);\n    gridLine = clamp( gridLine, 0.0, 1.0 );\n    \n    gridLine = isReversed\n        ? 1.0 - gridLine\n        : gridLine;\n    diffuseColor.a *= gridLine;\n\n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},280:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.CrossGridMaterial=void 0;const a=i(6709),r=t(i(3227)),s=t(i(3844)),o=i(6823);class u extends o.WavyGridMaterial{get gridWeight(){return this.uniforms.gridWeight.value}set gridWeight(n){this.uniforms.gridWeight.value=n}get radius(){return this.uniforms.radius.value}set radius(n){this.uniforms.radius.value=n}constructor(n){super((0,s.default)(),(0,r.default)(),n)}initUniforms(){this.uniforms=a.UniformsUtils.merge([o.WavyGridMaterial.getBasicUniforms(),{gridWeight:{value:.03},radius:{value:.15}}])}}e.CrossGridMaterial=u},5094:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ExpansionMaterial=void 0;const t=i(4928);class a extends t.ShaderPhongMaterial{get expansionStrength(){return this.uniforms.expansionStrength.value}set expansionStrength(n){this.uniforms.expansionStrength.value=n}constructor(n){super(null,null,n)}initDefines(){super.initDefines(),this.defines.USE_EXPANSION=!0}}e.ExpansionMaterial=a},5225:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\nvarying float vFbm;\nuniform float progress;\nuniform vec3 dissolveColor;\nuniform vec3 dissolveOutColor;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n    \n    diffuseColor.rgb += dissolveColor.rgb * sin(progress*PI);\n    diffuseColor.rgb = mix (diffuseColor.rgb, dissolveOutColor.rgb, vFbm );\n    diffuseColor.a -= vFbm;\n    \n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},8920:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.ExpansionDissolveMaterial=void 0;const a=i(4027),r=i(6709),s=i(678),o=t(i(5225)),u=t(i(9248));class l extends s.ShaderPhongMaterial{constructor(n){super((0,u.default)(),(0,o.default)(),n),this.speed=-.5,this.animationListener=n=>{this.addTime(n.delta/1e3)},this.isAnimate=this.isAnimate}addTime(n){this.isAnimate&&s.AnimationChunk.addTime(this,n)}get isAnimate(){return this.uniforms.isAnimate.value}set isAnimate(n){this.uniforms.isAnimate.value=n,this.isAnimate?this.startAnimation():this.stopAnimation()}get tiles(){return this.uniforms.tiles.value}set tiles(n){this.uniforms.tiles.value=n}get hashLoop(){return this.uniforms.hashLoop.value}set hashLoop(n){this.uniforms.hashLoop.value=n}get amp(){return this.uniforms.amp.value}set amp(n){this.uniforms.amp.value=n}get scaleMax(){return this.uniforms.scaleMax.value}set scaleMax(n){this.uniforms.scaleMax.value=n}get time(){return this.uniforms.time.value}set time(n){this.uniforms.time.value=n}get progress(){return this.uniforms.progress.value}set progress(n){this.uniforms.progress.value=n}get dissolveColor(){return this.uniforms.dissolveColor.value}set dissolveColor(n){this.uniforms.dissolveColor.value=n}get dissolveOutColor(){return this.uniforms.dissolveOutColor.value}set dissolveOutColor(n){this.uniforms.dissolveOutColor.value=n}initUniforms(){this.uniforms=r.UniformsUtils.merge([s.ShaderPhongMaterial.getBasicUniforms(),s.TilingFBMChunk.getUniform(),s.AnimationChunk.getUniform(),{scaleMax:{value:20},progress:{value:0},dissolveColor:{value:new r.Color(1,1,1)},dissolveOutColor:{value:new r.Color(0,0,0)}}])}initChunks(){super.initChunks(),s.TilingFBMChunk.registerChunk()}initDefines(){super.initDefines(),this.defines=Object.assign(this.defines,s.TilingFBMChunk.getDefines()),this.defines.USE_EXPANSION=!0}startAnimation(){a.RAFTicker.on(a.RAFTickerEventType.onBeforeTick,this.animationListener)}stopAnimation(){a.RAFTicker.off(a.RAFTickerEventType.onBeforeTick,this.animationListener)}}e.ExpansionDissolveMaterial=l},9248:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\nvarying vec3 vViewPosition;\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n#include <surface_normal_varying_chunk>\n#include <__expansion_uniform_chunk>\n#include <tiling_fbm_uniform_chunk>\nuniform float scaleMax;\nuniform float time;\nuniform float progress;\nvarying float vFbm;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tiling_fbm_function_chunk>\n\nvoid main() {\n    #include <mesh_position_vertex>\n    uvPosition = uv;\n\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n    \n    #include <beginnormal_vertex>\n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <normal_vertex>\n    \n    #include <surface_normal_vertex_chunk>\n\n    #include <begin_vertex>\n    \n    vec2 uvFBM = uvPosition;\n    uvFBM.x = (\n         uvFBM.y > 0.99 \n      || uvFBM.y < 0.01\n    ) \n      ? 0.5\n      : uvFBM.x;\n        \n    vec2 q = vec2(0.0);\n    q.x = fbm( uvFBM + vec2(1.7,9.2) +.16  * time );\n    q.y = fbm( uvFBM + vec2(8.3,2.8) +.356 * time );\n\n    float bottom = clamp(progress-0.5, 0.0, 0.5) *2.0;\n    \n    vec2 pos = uvFBM * tiles;\n    float noise = fbm( pos + q ) * progress;\n    vFbm = clamp( noise + bottom, 0.0, 1.0);\n    vec3 vExpansion = normal * vFbm * scaleMax;\n    transformed += vExpansion;\n    \n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n    \n    vViewPosition = - mvPosition.xyz;\n\n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n\n}\n"},6093:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n#include <tiling_fbm_uniform_chunk>\nuniform float progress;\nuniform vec3 edgeColor;\nuniform float edgeWeight;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n#include <tiling_fbm_function_chunk>\n\nvoid main()\n{\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n    \n    vec2 uv = uvPosition * tiles;\n\n    float fbmVal = fbm(uv);\n    float bri = 1.0 - smoothstep( progress-0.01, progress, fbmVal );\n\n    float edge = \n          smoothstep( progress-edgeWeight, progress, fbmVal )\n        - smoothstep( progress, progress+edgeWeight, fbmVal );\n    edge = clamp( edge, 0.0, 1.0 );\n\n    vec3 col = diffuseColor.rgb;\n    col += edgeColor * edge;\n\n    diffuseColor.rgb = col;\n    diffuseColor.a *= bri;\n    \n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},2769:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.FBMDissolveMaterial=void 0;const a=i(6709),r=i(6709),s=i(4928),o=i(6905),u=t(i(3844)),l=t(i(6093));class m extends s.ShaderPhongMaterial{get tiles(){return this.uniforms.tiles.value}set tiles(n){this.uniforms.tiles.value=n}get hashLoop(){return this.uniforms.hashLoop.value}set hashLoop(n){this.uniforms.hashLoop.value=n}get amp(){return this.uniforms.amp.value}set amp(n){this.uniforms.amp.value=n}get progress(){return this.uniforms.progress.value}set progress(n){this.uniforms.progress.value=n}get edgeWeight(){return this.uniforms.edgeWeight.value}set edgeWeight(n){this.uniforms.edgeWeight.value=n}get edgeColor(){return this.uniforms.edgeColor.value}set edgeColor(n){this.uniforms.edgeColor.value=n}constructor(n){super((0,u.default)(),(0,l.default)(),n)}initUniforms(){this.uniforms=a.UniformsUtils.merge([s.ShaderPhongMaterial.getBasicUniforms(),o.TilingFBMChunk.getUniform(),{progress:{value:0},edgeWeight:{value:.1},edgeColor:{value:new r.Color(1,1,1)}}])}initChunks(){super.initChunks(),o.TilingFBMChunk.registerChunk()}initDefines(){super.initDefines(),this.defines=Object.assign({},o.TilingFBMChunk.getDefines(),this.defines)}initDefaultSetting(n){super.initDefaultSetting(n),null==n.transparent?this.transparent=!0:this.transparent=n.transparent}}e.FBMDissolveMaterial=m},1550:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n#include <tiling_fbm_uniform_chunk>\n#include <time_animation_uniform_chunk>\n\nuniform float strength;\nuniform float bloom;\n\n#include <surface_normal_varying_chunk>\nuniform float rimStrength;\nuniform float rimPow;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n#include <tiling_fbm_function_chunk>\n\nvoid main()\n{\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n    \n    vec2 uv = uvPosition;\n    float uVy = uv.y;\n    uv *= tiles;\n\n    vec2 q = vec2(0.0);\n    q.x = fbm( uv + vec2(1.7,9.2) +.16  * time );\n    q.y = fbm( uv + vec2(8.3,2.8) +.356 * time );\n\n    float fbmVal = fbm(uv + q);\n    fbmVal += 1.0-(uVy * 1.0 );\n    fbmVal *= 1.0-uVy;\n    \n    vec3 viewDir = normalize(vViewPosition);    \n    float rimGlow = 1.0 - max(0.0, dot(surfaceNormal, viewDir));\n    rimGlow = pow(rimGlow, rimPow) * rimStrength;\n    rimGlow = clamp( rimGlow, 0.0, 1.0);\n    fbmVal *= 1.0-rimGlow;\n    \n    vec3 color = diffuseColor.rgb;\n    \n    float st = 1.0 - strength;\n    float bri = smoothstep( max( st - 0.4, 0.0 ), st, fbmVal );\n    \n    float blm = 1.0 - bloom;\n    float bloomVal = smoothstep( blm - 0.4, blm, fbmVal );\n    color += bloomVal;\n\n    diffuseColor.rgb = color;\n    diffuseColor.a *= bri;\n    \n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},5875:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.FBMFireMaterial=void 0;const a=i(4027),r=i(6709),s=i(3467),o=i(6905),u=i(4928),l=t(i(3844)),m=t(i(1550));class c extends u.ShaderPhongMaterial{constructor(n){super((0,l.default)(),(0,m.default)(),n),this.speed=-.5,this.animationListener=n=>{this.addTime(n.delta/1e3)},this.isAnimate=this.isAnimate}get tiles(){return this.uniforms.tiles.value}set tiles(n){this.uniforms.tiles.value=n}get hashLoop(){return this.uniforms.hashLoop.value}set hashLoop(n){this.uniforms.hashLoop.value=n}get amp(){return this.uniforms.amp.value}set amp(n){this.uniforms.amp.value=n}addTime(n){s.AnimationChunk.addTime(this,n)}get isAnimate(){return this.uniforms.isAnimate.value}set isAnimate(n){this.uniforms.isAnimate.value=n,this.isAnimate?this.startAnimation():this.stopAnimation()}get strength(){return this.uniforms.strength.value}set strength(n){this.uniforms.strength.value=n}get bloom(){return this.uniforms.bloom.value}set bloom(n){this.uniforms.bloom.value=n}get transformSpeed(){return this.uniforms.transformSpeed.value}set transformSpeed(n){this.uniforms.transformSpeed.value=n}get rimPow(){return this.uniforms.rimPow.value}set rimPow(n){this.uniforms.rimPow.value=n}get rimStrength(){return this.uniforms.rimStrength.value}set rimStrength(n){this.uniforms.rimStrength.value=n}initUniforms(){this.uniforms=r.UniformsUtils.merge([u.ShaderPhongMaterial.getBasicUniforms(),o.TilingFBMChunk.getUniform(),s.AnimationChunk.getUniform(),{strength:{value:.45},bloom:{value:.1},rimStrength:{value:1},rimPow:{value:1}}])}initChunks(){super.initChunks(),o.TilingFBMChunk.registerChunk(),s.AnimationChunk.registerChunk()}initDefines(){super.initDefines(),this.defines=Object.assign({},o.TilingFBMChunk.getDefines(),this.defines),this.defines.USE_SURFACE_NORMAL=!0}initDefaultSetting(n){super.initDefaultSetting(n),null==n.transparent?this.transparent=!0:this.transparent=n.transparent}startAnimation(){a.RAFTicker.on(a.RAFTickerEventType.onBeforeTick,this.animationListener)}stopAnimation(){a.RAFTicker.off(a.RAFTickerEventType.onBeforeTick,this.animationListener)}}e.FBMFireMaterial=c},3132:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n//user settings\n\n#include <time_animation_uniform_chunk>\n#include <wavy_animation_uniform_chunk>\n#include <repeat_pattern_uniform_chunk>\n#include <mask_map_uniform_chunk>\n#include <reversible_uniform_chunk>\nuniform float radius;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n\n    #include <repeat_pattern_fragment_chunk> \n    //\bhex angle\n    vec2 r = normalize(vec2(1.0, 1.73));\n    vec2 halfR = r * 0.5;\n\n    vec2 p1 = mod(uv, r) - halfR;\n    vec2 p2 = mod(uv - halfR, r) - halfR;\n\n    vec2 localPos = length(p1) < length(p2) ? p1 : p2;\n\n    vec2 id = uv - localPos;\n    #include <wavy_animation_fragment_chunk>\n\n    #include <mask_map_fragment_chunk>\n    float ln = length(localPos);\n    float current = 1.0 - ( ln * 4.0 / radius / mask );\n    current = clamp( current, 0.0, 1.0 );\n\n    float alpha = smoothstep ( 0.0, 0.1, current );\n    alpha = isReversed\n        ? 1.0 - alpha\n        : alpha;\n    \n    diffuseColor.a *= alpha;\n\n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},5732:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.HalftoneGridMaterial=void 0;const a=i(6709),r=t(i(3132)),s=t(i(3844)),o=i(6823);class u extends o.WavyGridMaterial{get radius(){return this.uniforms.radius.value}set radius(n){this.uniforms.radius.value=n}constructor(n){super((0,s.default)(),(0,r.default)(),n)}initUniforms(){this.uniforms=a.UniformsUtils.merge([o.WavyGridMaterial.getBasicUniforms(),{radius:{value:.75}}])}}e.HalftoneGridMaterial=u},1954:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n//user settings\n#include <repeat_pattern_uniform_chunk>\n#include <mask_map_uniform_chunk>\n#include <reversible_uniform_chunk>\nuniform float progress;\nuniform float delay;\nuniform float gridWeight;\nuniform bool isAscending;\n\nuniform vec3 gridEmissive;\nuniform float gridEmissiveWeight;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n#include <hex_grid_function_chunk>\n\nfloat reverse( float val, bool isReversed){\n  return isReversed ? 1.0 - val : val;\n}\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n\n    #include <repeat_pattern_fragment_chunk>    \n    vec4 hc = hexCoords( uv );\n    vec2 id = hc.zw;\n\n    #include <mask_map_fragment_chunk>\n  \n    float range = 1.0 - delay;\n    float rateY = isAscending \n      ? ( division-id.y ) / division\n      : id.y  / division;\n  \n    float currentProgress = progress - (rateY * delay);\n    currentProgress /= range;\n    currentProgress = clamp( currentProgress, 0.0, 1.0);\n  \n    float w = gridWeight + currentProgress / 2.0 + (1.0 - mask);\n    w = clamp( w, 0.0, 1.0);\n    float margin = clamp ( w * 0.33, 0.00, 0.02 );\n  \n    float gridLine = smoothstep(w, w + margin, hc.y);\n    gridLine =  reverse ( gridLine , isReversed);\n    diffuseColor.a *= gridLine ;\n    \n    float emmesiveWeight = currentProgress / 2.0 * gridEmissiveWeight;\n    emmesiveWeight =  reverse ( emmesiveWeight, isReversed );\n    float emissiveVal = smoothstep(emmesiveWeight, emmesiveWeight + margin, hc.y);\n    emissiveVal = 1.0 - emissiveVal;\n    diffuseColor.rgb += gridEmissive * emissiveVal;\n\n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},4576:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.HexDissolveMaterial=void 0;const a=i(6709),r=t(i(1954)),s=i(678),o=i(5072),u=i(6709);class l extends o.GridMaterial{get progress(){return this.uniforms.progress.value}set progress(n){this.uniforms.progress.value=n}get delay(){return this.uniforms.delay.value}set delay(n){this.uniforms.delay.value=n}get isAscending(){return this.uniforms.isAscending.value}set isAscending(n){this.uniforms.isAscending.value=n}get gridWeight(){return this.uniforms.gridWeight.value}set gridWeight(n){this.uniforms.gridWeight.value=n}get gridEmissive(){return this.uniforms.gridEmissive.value}set gridEmissive(n){this.uniforms.gridEmissive.value=n}get gridEmissiveWeight(){return this.uniforms.gridEmissiveWeight.value}set gridEmissiveWeight(n){this.uniforms.gridEmissiveWeight.value=n}constructor(n){super(null,(0,r.default)(),n)}initUniforms(){this.uniforms=a.UniformsUtils.merge([o.GridMaterial.getBasicUniforms(),{progress:{value:0},delay:{value:.8},gridWeight:{value:0},isAscending:{value:!0},gridEmissive:{value:new u.Color(0)},gridEmissiveWeight:{value:2.5}}])}initChunks(){super.initChunks(),s.HexGridChunk.registerChunk()}}e.HexDissolveMaterial=l},9206:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n//user settings\n#include <time_animation_uniform_chunk>\n#include <wavy_animation_uniform_chunk>\n#include <repeat_pattern_uniform_chunk>\n#include <mask_map_uniform_chunk>\n#include <reversible_uniform_chunk>\nuniform float gridWeight;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n#include <hex_grid_function_chunk>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n\n    #include <repeat_pattern_fragment_chunk>    \n    vec4 hc = hexCoords( uv );\n    vec2 id = hc.zw;\n    #include <wavy_animation_fragment_chunk>\n\n    #include <mask_map_fragment_chunk>\n    float w = gridWeight + (1.0-mask);\n    w = clamp( w, 0.0, 1.0);\n\n    float margin = clamp ( w * 0.33, 0.00, 0.02 );\n    float stepMax = w + margin;\n\n    float gridLine = smoothstep(w, stepMax, hc.y);\n    gridLine = isReversed\n        ? 1.0 - gridLine\n        : gridLine;\n    diffuseColor.a *= gridLine ;\n\n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},7026:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.HexGridMaterial=void 0;const a=i(6709),r=i(6823),s=t(i(9206)),o=t(i(3844)),u=i(5867);class l extends r.WavyGridMaterial{get gridWeight(){return this.uniforms.gridWeight.value}set gridWeight(n){this.uniforms.gridWeight.value=n}constructor(n){super((0,o.default)(),(0,s.default)(),n)}initUniforms(){this.uniforms=a.UniformsUtils.merge([r.WavyGridMaterial.getBasicUniforms(),{gridWeight:{value:.03}}])}initChunks(){super.initChunks(),u.HexGridChunk.registerChunk()}}e.HexGridMaterial=l},678:function(n,e,i){var t=this&&this.__createBinding||(Object.create?function(n,e,i,t){void 0===t&&(t=i),Object.defineProperty(n,t,{enumerable:!0,get:function(){return e[i]}})}:function(n,e,i,t){void 0===t&&(t=i),n[t]=e[i]}),a=this&&this.__exportStar||function(n,e){for(var i in n)"default"===i||Object.prototype.hasOwnProperty.call(e,i)||t(e,n,i)};Object.defineProperty(e,"__esModule",{value:!0}),a(i(4928),e),a(i(3477),e),a(i(4711),e),a(i(4322),e),a(i(280),e),a(i(5732),e),a(i(7026),e),a(i(3273),e),a(i(4935),e),a(i(2769),e),a(i(5875),e),a(i(2405),e),a(i(575),e),a(i(5094),e),a(i(899),e),a(i(8920),e),a(i(6318),e),a(i(9366),e),a(i(8632),e),a(i(4576),e)},575:(n,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.OuterGlowMaterial=void 0;const t=i(2405);class a extends t.RimEffectMaterial{get expansionStrength(){return this.uniforms.expansionStrength.value}set expansionStrength(n){this.uniforms.expansionStrength.value=n}initDefines(){super.initDefines(),this.defines.USE_LIGHT=!1,this.defines.USE_EXPANSION=!0}}e.OuterGlowMaterial=a},1002:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <surface_normal_varying_chunk>\n\nuniform vec3 rimColor;\nuniform float rimStrength;\nuniform float rimPow;\n\nuniform vec3 insideColor;\nuniform float insideStrength;\nuniform float insidePow;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    \n    vec3 viewDir = normalize(vViewPosition);    \n    \n    float rimGlow = 1.0 - max(0.0, dot(surfaceNormal, viewDir));\n    rimGlow = pow( rimGlow, rimPow);\n    diffuseColor.rgb += rimColor * rimGlow * rimStrength;\n\n    float insideGlow = max(0.0, dot(surfaceNormal, viewDir));\n    insideGlow = pow( insideGlow, insidePow);\n    diffuseColor.rgb += insideColor * insideGlow * insideStrength;\n\n    #include <color_fragment>\n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    #ifdef USE_LIGHT\n      gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #else\n      gl_FragColor = diffuseColor;\n    #endif\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},2405:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.RimEffectMaterial=void 0;const a=i(4928),r=t(i(1002)),s=i(6709),o=i(6709);class u extends a.ShaderPhongMaterial{get rimPow(){return this.uniforms.rimPow.value}set rimPow(n){this.uniforms.rimPow.value=n}get rimStrength(){return this.uniforms.rimStrength.value}set rimStrength(n){this.uniforms.rimStrength.value=n}get rimColor(){return this.uniforms.rimColor.value}set rimColor(n){this.uniforms.rimColor.value=n}get insidePow(){return this.uniforms.insidePow.value}set insidePow(n){this.uniforms.insidePow.value=n}get insideStrength(){return this.uniforms.insideStrength.value}set insideStrength(n){this.uniforms.insideStrength.value=n}get insideColor(){return this.uniforms.insideColor.value}set insideColor(n){this.uniforms.insideColor.value=n}constructor(n){super(null,(0,r.default)(),n)}initUniforms(){this.uniforms=s.UniformsUtils.merge([a.ShaderPhongMaterial.getBasicUniforms(),{rimColor:{value:new o.Color(1,1,1)},rimStrength:{value:1},rimPow:{value:1},insideColor:{value:new o.Color(0,0,0)},insideStrength:{value:1},insidePow:{value:1}}])}initDefines(){super.initDefines(),this.defines.USE_LIGHT=!0,this.defines.USE_SURFACE_NORMAL=!0}}e.RimEffectMaterial=u},5445:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\n\n//varying\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n//user settings\n#include <time_animation_uniform_chunk>\nuniform float scale;\nuniform float cloudVolume;\nuniform float cloudTransformSpeed;\nuniform vec3 skyColor;\nuniform float cloudBottomVolume;\nuniform float cloudBottomSaturation;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// <https://www.shadertoy.com/view/4dS3Wd>\n// <https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83>\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\nfloat hash(vec2 p)\n{\n  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\n/**\n * Based on Morgan McGuire @morgan3d\n * https://www.shadertoy.com/view/4dS3Wd\n */ \nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 7\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n    \n    vec2 st = uvPosition * scale;\n    st += time;\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + time);\n    q.y = fbm( st + vec2(1.0));\n\n    vec2 r = vec2(0.0);\n    r.x = fbm( st + q + vec2(1.7,9.2)+ 0.15*time * cloudTransformSpeed);\n    r.y = fbm( st + q + vec2(8.3,2.8)+ 0.126*time * cloudTransformSpeed);\n    float f = fbm(st+r);\n\n    vec3 cloudColor = diffuseColor.rgb;\n    \n    float volume;\n    float alpha = 0.0;\n    volume = (f*f)*cloudVolume*0.03;\n    alpha += volume;\n    volume = (f*f*f*f*f)*cloudVolume;\n    alpha += volume;\n    alpha = clamp(alpha,0.0,1.0);\n    \n    cloudColor = mix(cloudColor,\n                skyColor*cloudBottomSaturation,\n                clamp(volume*cloudBottomVolume,0.0,1.0));\n\n    diffuseColor.rgb = cloudColor;\n    diffuseColor.a *= alpha;\n    \n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},4935:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.SkyCloudMaterial=void 0;const a=i(4027),r=i(6709),s=i(3467),o=i(4928),u=t(i(3844)),l=t(i(5445));class m extends o.ShaderPhongMaterial{constructor(n){super((0,u.default)(),(0,l.default)(),n),this.speed=-.02,this.animationListener=n=>{this.addTime(n.delta/1e3)},this.isAnimate=this.isAnimate}get scale(){return this.uniforms.scale.value}set scale(n){this.uniforms.scale.value=n}addTime(n){s.AnimationChunk.addTime(this,n)}get isAnimate(){return this.uniforms.isAnimate.value}set isAnimate(n){this.uniforms.isAnimate.value=n,this.isAnimate?this.startAnimation():this.stopAnimation()}get skyColor(){return this.uniforms.skyColor.value}set skyColor(n){this.uniforms.skyColor.value=n}get cloudVolume(){return this.uniforms.cloudVolume.value}set cloudVolume(n){this.uniforms.cloudVolume.value=n}get cloudBottomVolume(){return this.uniforms.cloudBottomVolume.value}set cloudBottomVolume(n){this.uniforms.cloudBottomVolume.value=n}get cloudBottomSaturation(){return this.uniforms.cloudBottomSaturation.value}set cloudBottomSaturation(n){this.uniforms.cloudBottomSaturation.value=n}get cloudTransformSpeed(){return this.uniforms.cloudTransformSpeed.value}set cloudTransformSpeed(n){this.uniforms.cloudTransformSpeed.value=n}initChunks(){super.initChunks(),s.AnimationChunk.registerChunk()}initUniforms(){this.uniforms=r.UniformsUtils.merge([o.ShaderPhongMaterial.getBasicUniforms(),s.AnimationChunk.getUniform(),{scale:{value:3},cloudTransformSpeed:{value:.15},cloudVolume:{value:16},cloudBottomVolume:{value:.08},cloudBottomSaturation:{value:.5},skyColor:{value:new r.Color(.101961,.619608,.666667)}}])}initDefaultSetting(n){super.initDefaultSetting(n),null==n.transparent?this.transparent=!0:this.transparent=n.transparent}startAnimation(){a.RAFTicker.on(a.RAFTickerEventType.onBeforeTick,this.animationListener)}stopAnimation(){a.RAFTicker.off(a.RAFTickerEventType.onBeforeTick,this.animationListener)}}e.SkyCloudMaterial=m},305:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\nuniform vec3 cutSectionColor;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n  \n    outgoingLight = gl_FrontFacing ? outgoingLight : cutSectionColor;\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    \n    vec4 fragment = vec4(gl_FragColor);\n    #include <fog_fragment>\n    gl_FragColor = gl_FrontFacing ? gl_FragColor : fragment;\n    \n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},8632:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.SolidClippingMaterial=void 0;const a=i(678),r=i(6709),s=t(i(305)),o=i(6709);class u extends a.ShaderPhongMaterial{get cutSectionColor(){return this.uniforms.cutSectionColor.value}set cutSectionColor(n){this.uniforms.cutSectionColor.value=n}constructor(n){super(null,(0,s.default)(),n)}initUniforms(){this.uniforms=r.UniformsUtils.merge([a.ShaderPhongMaterial.getBasicUniforms(),{cutSectionColor:{value:new r.Color(1,1,1)}}])}initDefaultSetting(n){super.initDefaultSetting(n),this.clipping=!0,this.side=o.DoubleSide}}e.SolidClippingMaterial=u},5349:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n\nuniform float rimStrength;\nuniform float bottomStrength;\nuniform vec3 rimColor;\nuniform vec3 skyColor;\n\nuniform float rimCenter;\nuniform float rimRange;\n\n#include <sprite_fragment_uniform_chunk>\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\n    vec3 color = diffuse;\n    #include <clipping_planes_fragment>\n    #include <sprite_diffuse_color_chunk>\n\t#include <logdepthbuf_fragment>\n\t\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\t\n\tfloat bottom = 0.0;\t\n\t#ifdef USE_MAP\n      bottom = 1.0 - texture2D( map, vUv ).g;\n      bottom *= bottomStrength;\n    #endif\n    \n    float rim = 0.0;\n    #ifdef USE_MAP\n      float a = texture2D( map, vUv ).a ;\n      float edge = \n          smoothstep( rimCenter-rimRange, rimCenter, a )\n        - smoothstep( rimCenter, rimCenter+rimRange, a );\n    #endif\n    \n    outgoingLight = mix( diffuse, skyColor, bottom);\n    outgoingLight += rimColor * edge * rimStrength;\n    \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"},899:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.SpriteCloudMaterial=void 0;const a=i(6709),r=i(6709),s=i(3477),o=t(i(5349));class u extends s.ShaderSpriteMaterial{constructor(n){super(null,(0,o.default)(),n)}initUniforms(){super.initUniforms(),this.uniforms=a.UniformsUtils.merge([this.uniforms,{rimStrength:{value:.2},bottomStrength:{value:.75},rimColor:{value:new r.Color(16777215)},skyColor:{value:new r.Color(13421772)},rimCenter:{value:.6},rimRange:{value:.15}}])}initDefaultSetting(n){super.initDefaultSetting(n)}get rimCenter(){return this.uniforms.rimCenter.value}set rimCenter(n){this.uniforms.rimCenter.value=n}get rimRange(){return this.uniforms.rimRange.value}set rimRange(n){this.uniforms.rimRange.value=n}get rimStrength(){return this.uniforms.rimStrength.value}set rimStrength(n){this.uniforms.rimStrength.value=n}get bottomStrength(){return this.uniforms.bottomStrength.value}set bottomStrength(n){this.uniforms.bottomStrength.value=n}get rimColor(){return this.uniforms.rimColor.value}set rimColor(n){this.uniforms.rimColor.value=n}get skyColor(){return this.uniforms.skyColor.value}set skyColor(n){this.uniforms.skyColor.value=n}}e.SpriteCloudMaterial=u},3830:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n//user settings\n#include <time_animation_uniform_chunk>\n#include <wavy_animation_uniform_chunk>\n#include <repeat_pattern_uniform_chunk>\n#include <mask_map_uniform_chunk>\n#include <reversible_uniform_chunk>\nuniform float gridWeight;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    #include <color_fragment>\n\n    #include <repeat_pattern_fragment_chunk>    \n    vec2 localPos = mod(uv, 1.0) - 0.5;\n    vec2 id = uv - localPos;\n    #include <wavy_animation_fragment_chunk>\n\n    #include <mask_map_fragment_chunk>\n    float w = gridWeight + (1.0-mask);\n    w = clamp( w, 0.0, 1.0);\n    float margin = clamp ( w * 0.33, 0.03, 0.1 );\n    \n    float stepHigh = 0.5-(w+margin);\n    float stepLow = -0.5+w+margin;\n    \n    //float gridLine = smoothstep(w, stepMax, hc.y);\n    float gridLine = smoothstep ( 0.5-w, stepHigh, localPos.x );\n    gridLine *= smoothstep ( 0.5-w, stepHigh, localPos.y );\n    gridLine *= smoothstep ( -0.5+w, stepLow, localPos.x );\n    gridLine *= smoothstep ( -0.5+w, stepLow, localPos.y );\n    \n    gridLine = isReversed\n        ? 1.0 - gridLine\n        : gridLine;\n    diffuseColor.a *= gridLine;\n\n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},3273:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.SquareGridMaterial=void 0;const a=i(6709),r=t(i(3830)),s=t(i(3844)),o=i(6823);class u extends o.WavyGridMaterial{get gridWeight(){return this.uniforms.gridWeight.value}set gridWeight(n){this.uniforms.gridWeight.value=n}constructor(n){super((0,s.default)(),(0,r.default)(),n)}initUniforms(){this.uniforms=a.UniformsUtils.merge([o.WavyGridMaterial.getBasicUniforms(),{gridWeight:{value:.03}}])}}e.SquareGridMaterial=u},7744:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=()=>"\n#define PHONG\n\n#include <mesh_phong_uniform>\nvarying vec2 uvPosition;\n#include <mesh_position_varying>\n\n#include <time_animation_uniform_chunk>\nuniform float uvRotation;\nuniform float swirlRotation;\nuniform float radius;\nuniform vec2 center;\n#include <map_uniform_chunk>\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n/**\n * UV座標を回転する\n */\nvec2 rotateUV(vec2 uv, float rotation, vec2 center)\n{\n  return vec2(\n    cos(rotation) * (uv.x - center.x) + sin(rotation) * (uv.y - center.y) + center.x,\n    cos(rotation) * (uv.y - center.y) - sin(rotation) * (uv.x - center.x) + center.y\n  );\n}\n\n/**\n * UV座標をツイストする\n */\nvec2 swirl(vec2 uv, float radius, float rotation, vec2 center)\n{\n  vec2 tc = uv - center;\n  float dist = length(tc);\n  if (dist < radius) \n  {\n    float percent = (radius - dist) / radius;\n    float theta = percent * percent * rotation;\n    float s = sin(theta);\n    float c = cos(theta);\n    tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));\n  }\n  tc += center;\n  return tc;\n}\n\nvoid main() {\n    #include <clipping_planes_fragment>\n  \n    #include <mesh_phong_diffuse_color>\n    \n    #include <logdepthbuf_fragment>\n    #include <__ShaderMaterial__map_fragment_begin_chunk>\n    #include <map_fragment>\n    mapUV = rotateUV( mapUV, uvRotation , center);\n    mapUV = swirl( mapUV, radius, swirlRotation, center );\n    // offset Texture \n    mapUV += vec2(time);\n    #include <map_fragment_chunk>\n    \n    #include <color_fragment>\n    #include <mesh_phong_switching_alpha_map>\n    \n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <emissivemap_fragment>\n    \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    // modulation\n    #include <aomap_fragment>\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n}"},6318:function(n,e,i){var t=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.SwirlMaterial=void 0;const a=i(4027),r=i(6709),s=i(678),o=t(i(7744));class u extends s.ShaderPhongMaterial{constructor(n){super(null,(0,o.default)(),n),this.speed=-.02,this.animationListener=n=>{this.addTime(n.delta/1e3)},this.isAnimate=this.isAnimate}addTime(n){this.isAnimate&&s.AnimationChunk.addTime(this,n)}get isAnimate(){return this.uniforms.isAnimate.value}set isAnimate(n){this.uniforms.isAnimate.value=n,this.isAnimate?this.startAnimation():this.stopAnimation()}onSetMap(n){super.onSetMap(n),this.setRepeat(n)}onSetAlphaMap(n){super.onSetAlphaMap(n),this.setRepeat(n)}setRepeat(n){n&&(n.wrapS=r.RepeatWrapping,n.wrapT=r.RepeatWrapping)}get uvRotation(){return this.uniforms.uvRotation.value}set uvRotation(n){this.uniforms.uvRotation.value=n}get swirlRotation(){return this.uniforms.swirlRotation.value}set swirlRotation(n){this.uniforms.swirlRotation.value=n}get radius(){return this.uniforms.radius.value}set radius(n){this.uniforms.radius.value=n}get center(){return this.uniforms.center.value}set center(n){this.uniforms.center.value=n}initChunks(){super.initChunks(),s.AnimationChunk.registerChunk()}initUniforms(){this.uniforms=r.UniformsUtils.merge([s.ShaderPhongMaterial.getBasicUniforms(),s.AnimationChunk.getUniform(),{uvRotation:{value:0},swirlRotation:{value:3.14},radius:{value:.5},center:{value:new r.Vector2(.5,.5)}}])}startAnimation(){a.RAFTicker.on(a.RAFTickerEventType.onBeforeTick,this.animationListener)}stopAnimation(){a.RAFTicker.off(a.RAFTickerEventType.onBeforeTick,this.animationListener)}}e.SwirlMaterial=u}},i={};function t(n){var a=i[n];if(void 0!==a)return a.exports;var r=i[n]={exports:{}};return e[n].call(r.exports,r,r.exports,t),r.exports}t.m=e,n=[],t.O=(e,i,a,r)=>{if(!i){var s=1/0;for(m=0;m<n.length;m++){for(var[i,a,r]=n[m],o=!0,u=0;u<i.length;u++)(!1&r||s>=r)&&Object.keys(t.O).every((n=>t.O[n](i[u])))?i.splice(u--,1):(o=!1,r<s&&(s=r));if(o){n.splice(m--,1);var l=a();void 0!==l&&(e=l)}}return e}r=r||0;for(var m=n.length;m>0&&n[m-1][2]>r;m--)n[m]=n[m-1];n[m]=[i,a,r]},t.n=n=>{var e=n&&n.__esModule?()=>n.default:()=>n;return t.d(e,{a:e}),e},t.d=(n,e)=>{for(var i in e)t.o(e,i)&&!t.o(n,i)&&Object.defineProperty(n,i,{enumerable:!0,get:e[i]})},t.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),t.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},(()=>{var n={797:0};t.O.j=e=>0===n[e];var e=(e,i)=>{var a,r,[s,o,u]=i,l=0;if(s.some((e=>0!==n[e]))){for(a in o)t.o(o,a)&&(t.m[a]=o[a]);if(u)var m=u(t)}for(e&&e(i);l<s.length;l++)r=s[l],t.o(n,r)&&n[r]&&n[r][0](),n[s[l]]=0;return t.O(m)},i=self.webpackChunkthreejs_shader_materials=self.webpackChunkthreejs_shader_materials||[];i.forEach(e.bind(null,0)),i.push=e.bind(null,i.push.bind(i))})();var a=t.O(void 0,[736],(()=>t(518)));a=t.O(a)})();